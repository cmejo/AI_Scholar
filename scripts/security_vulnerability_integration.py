#!/usr/bin/env python3
"""
Security Vulnerability Scanner Integration Test

This module provides integration testing for the security vulnerability scanner
with real project files and comprehensive validation.
"""

import os
import sys
import json
import tempfile
import shutil
from pathlib import Path
from typing import Dict, List, Any

# Add the scripts directory to the Python path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from security_vulnerability_scanner import SecurityVulnerabilityScanner
from run_security_vulnerability_scan import main as run_scanner_main

class SecurityScannerIntegrationTest:
    """Integration test for security vulnerability scanner."""
    
    def __init__(self, project_root: str = "."):
        self.project_root = Path(project_root).resolve()
        self.test_results = {
            'timestamp': None,
            'tests_run': 0,
            'tests_passed': 0,
            'tests_failed': 0,
            'scan_results': None,
            'validation_results': {}
        }
    
    def run_integration_tests(self) -> Dict[str, Any]:
        """Run comprehensive integration tests."""
        print("Starting Security Vulnerability Scanner Integration Tests...")
        print("=" * 60)
        
        try:
            # Test 1: Basic scanner functionality
            self._test_basic_scanner_functionality()
            
            # Test 2: Real project scanning
            self._test_real_project_scanning()
            
            # Test 3: Report generation
            self._test_report_generation()
            
            # Test 4: Ubuntu compatibility validation
            self._test_ubuntu_compatibility_validation()
            
            # Test 5: Security issue detection accuracy
            self._test_security_issue_detection()
            
            # Test 6: Performance and scalability
            self._test_performance_scalability()
            
            # Test 7: CLI interface
            self._test_cli_interface()
            
            # Generate final results
            self._generate_test_summary()
            
        except Exception as e:
            print(f"Integration test failed: {e}")
            self.test_results['tests_failed'] += 1
        
        return self.test_results
    
    def _test_basic_scanner_functionality(self):
        """Test basic scanner functionality."""
        print("\n1. Testing Basic Scanner Functionality...")
        self.test_results['tests_run'] += 1
        
        try:
            scanner = SecurityVulnerabilityScanner(self.project_root)
            
            # Test scanner initialization
            assert scanner.project_root.exists(), "Project root should exist"
            assert len(scanner.issues) == 0, "Issues list should be empty initially"
            assert 'timestamp' in scanner.scan_results, "Scan results should have timestamp"
            
            print("   ✓ Scanner initialization successful")
            self.test_results['tests_passed'] += 1
            
        except Exception as e:
            print(f"   ✗ Basic functionality test failed: {e}")
            self.test_results['tests_failed'] += 1
    
    def _test_real_project_scanning(self):
        """Test scanning real project files."""
        print("\n2. Testing Real Project Scanning...")
        self.test_results['tests_run'] += 1
        
        try:
            scanner = SecurityVulnerabilityScanner(self.project_root)
            results = scanner.run_comprehensive_scan()
            
            # Validate results structure
            assert 'summary' in results, "Results should contain summary"
            assert 'issues' in results, "Results should contain issues"
            assert 'recommendations' in results, "Results should contain recommendations"
            
            summary = results['summary']
            assert 'total_issues' in summary, "Summary should contain total_issues"
            assert 'critical_issues' in summary, "Summary should contain critical_issues"
            assert 'ubuntu_specific_issues' in summary, "Summary should contain ubuntu_specific_issues"
            
            # Store results for other tests
            self.test_results['scan_results'] = results
            
            print(f"   ✓ Scan completed successfully")
            print(f"   ✓ Found {summary['total_issues']} total issues")
            print(f"   ✓ Found {summary['critical_issues']} critical issues")
            print(f"   ✓ Found {summary['ubuntu_specific_issues']} Ubuntu-specific issues")
            
            self.test_results['tests_passed'] += 1
            
        except Exception as e:
            print(f"   ✗ Real project scanning test failed: {e}")
            self.test_results['tests_failed'] += 1
    
    def _test_report_generation(self):
        """Test report generation functionality."""
        print("\n3. Testing Report Generation...")
        self.test_results['tests_run'] += 1
        
        try:
            if not self.test_results['scan_results']:
                print("   ⚠ Skipping report generation test (no scan results)")
                return
            
            with tempfile.TemporaryDirectory() as temp_dir:
                from run_security_vulnerability_scan import generate_report
                
                results = self.test_results['scan_results']
                report_files = generate_report(results, Path(temp_dir))
                
                # Validate report files
                for report_type, report_file in report_files.items():
                    assert report_file.exists(), f"{report_type} should be generated"
                    assert report_file.stat().st_size > 0, f"{report_type} should not be empty"
                
                print("   ✓ JSON report generated successfully")
                print("   ✓ Markdown report generated successfully")
                print("   ✓ Summary report generated successfully")
                
                self.test_results['tests_passed'] += 1
                
        except Exception as e:
            print(f"   ✗ Report generation test failed: {e}")
            self.test_results['tests_failed'] += 1
    
    def _test_ubuntu_compatibility_validation(self):
        """Test Ubuntu compatibility validation."""
        print("\n4. Testing Ubuntu Compatibility Validation...")
        self.test_results['tests_run'] += 1
        
        try:
            if not self.test_results['scan_results']:
                print("   ⚠ Skipping Ubuntu compatibility test (no scan results)")
                return
            
            results = self.test_results['scan_results']
            issues = results['issues']
            
            # Check for Ubuntu-specific issues
            ubuntu_issues = [issue for issue in issues if issue['ubuntu_specific']]
            
            # Validate Ubuntu-specific issue types
            expected_ubuntu_types = [
                'file_permission',
                'network_security',
                'configuration'
            ]
            
            ubuntu_types_found = set()
            for issue in ubuntu_issues:
                ubuntu_types_found.add(issue['type'])
            
            print(f"   ✓ Found {len(ubuntu_issues)} Ubuntu-specific issues")
            print(f"   ✓ Ubuntu issue types found: {', '.join(ubuntu_types_found)}")
            
            # Check for common Ubuntu compatibility patterns
            validation_checks = {
                'file_permissions': self._validate_file_permission_checks(ubuntu_issues),
                'docker_compatibility': self._validate_docker_compatibility_checks(ubuntu_issues),
                'network_security': self._validate_network_security_checks(ubuntu_issues)
            }
            
            self.test_results['validation_results']['ubuntu_compatibility'] = validation_checks
            
            for check_name, passed in validation_checks.items():
                status = "✓" if passed else "⚠"
                print(f"   {status} {check_name.replace('_', ' ').title()}: {'Passed' if passed else 'Needs attention'}")
            
            self.test_results['tests_passed'] += 1
            
        except Exception as e:
            print(f"   ✗ Ubuntu compatibility validation test failed: {e}")
            self.test_results['tests_failed'] += 1
    
    def _test_security_issue_detection(self):
        """Test security issue detection accuracy."""
        print("\n5. Testing Security Issue Detection...")
        self.test_results['tests_run'] += 1
        
        try:
            if not self.test_results['scan_results']:
                print("   ⚠ Skipping security issue detection test (no scan results)")
                return
            
            results = self.test_results['scan_results']
            issues = results['issues']
            
            # Check for different types of security issues
            issue_types = {}
            for issue in issues:
                issue_type = issue['type']
                if issue_type not in issue_types:
                    issue_types[issue_type] = 0
                issue_types[issue_type] += 1
            
            print(f"   ✓ Detected {len(issue_types)} different issue types")
            
            # Validate critical security checks
            security_validations = {
                'dependency_vulnerabilities': 'dependency_vulnerability' in issue_types,
                'authentication_issues': 'authentication' in issue_types,
                'authorization_issues': 'authorization' in issue_types,
                'configuration_issues': 'configuration' in issue_types,
                'secrets_exposure': 'secrets_exposure' in issue_types
            }
            
            for validation_name, found in security_validations.items():
                status = "✓" if found else "⚠"
                print(f"   {status} {validation_name.replace('_', ' ').title()}: {'Found' if found else 'Not detected'}")
            
            self.test_results['validation_results']['security_detection'] = security_validations
            self.test_results['tests_passed'] += 1
            
        except Exception as e:
            print(f"   ✗ Security issue detection test failed: {e}")
            self.test_results['tests_failed'] += 1
    
    def _test_performance_scalability(self):
        """Test performance and scalability."""
        print("\n6. Testing Performance and Scalability...")
        self.test_results['tests_run'] += 1
        
        try:
            import time
            
            start_time = time.time()
            scanner = SecurityVulnerabilityScanner(self.project_root)
            results = scanner.run_comprehensive_scan()
            end_time = time.time()
            
            scan_duration = end_time - start_time
            total_issues = results['summary']['total_issues']
            
            # Performance benchmarks
            max_scan_time = 300  # 5 minutes max for reasonable projects
            min_issues_per_second = 1  # At least 1 issue per second processing
            
            performance_ok = scan_duration < max_scan_time
            throughput_ok = total_issues == 0 or (total_issues / scan_duration) >= min_issues_per_second
            
            print(f"   ✓ Scan completed in {scan_duration:.2f} seconds")
            print(f"   ✓ Processed {total_issues} issues")
            
            if performance_ok:
                print(f"   ✓ Performance: Within acceptable limits")
            else:
                print(f"   ⚠ Performance: Scan took {scan_duration:.2f}s (max: {max_scan_time}s)")
            
            if throughput_ok:
                print(f"   ✓ Throughput: Acceptable processing speed")
            else:
                print(f"   ⚠ Throughput: Processing speed below threshold")
            
            self.test_results['validation_results']['performance'] = {
                'scan_duration': scan_duration,
                'total_issues': total_issues,
                'performance_ok': performance_ok,
                'throughput_ok': throughput_ok
            }
            
            self.test_results['tests_passed'] += 1
            
        except Exception as e:
            print(f"   ✗ Performance and scalability test failed: {e}")
            self.test_results['tests_failed'] += 1
    
    def _test_cli_interface(self):
        """Test CLI interface functionality."""
        print("\n7. Testing CLI Interface...")
        self.test_results['tests_run'] += 1
        
        try:
            with tempfile.TemporaryDirectory() as temp_dir:
                output_file = Path(temp_dir) / "cli_test_output.json"
                
                # Test CLI with JSON output
                import subprocess
                result = subprocess.run([
                    sys.executable, 
                    str(Path(__file__).parent / "run_security_vulnerability_scan.py"),
                    "--project-root", str(self.project_root),
                    "--output", str(output_file),
                    "--no-reports"
                ], capture_output=True, text=True, timeout=300)
                
                # Validate CLI execution
                assert result.returncode in [0, 1], f"CLI should return 0 or 1, got {result.returncode}"
                assert output_file.exists(), "CLI should generate output file"
                
                # Validate output file content
                with open(output_file, 'r') as f:
                    cli_results = json.load(f)
                
                assert 'summary' in cli_results, "CLI output should contain summary"
                assert 'issues' in cli_results, "CLI output should contain issues"
                
                print("   ✓ CLI execution successful")
                print("   ✓ JSON output generated correctly")
                print(f"   ✓ CLI exit code: {result.returncode}")
                
                self.test_results['tests_passed'] += 1
                
        except Exception as e:
            print(f"   ✗ CLI interface test failed: {e}")
            self.test_results['tests_failed'] += 1
    
    def _validate_file_permission_checks(self, ubuntu_issues: List[Dict]) -> bool:
        """Validate file permission checks."""
        permission_issues = [issue for issue in ubuntu_issues 
                           if issue['type'] == 'file_permission']
        
        # Check for common permission issues
        expected_patterns = [
            'world-writable',
            'executable',
            'permissions'
        ]
        
        found_patterns = set()
        for issue in permission_issues:
            description = issue['description'].lower()
            for pattern in expected_patterns:
                if pattern in description:
                    found_patterns.add(pattern)
        
        return len(found_patterns) > 0
    
    def _validate_docker_compatibility_checks(self, ubuntu_issues: List[Dict]) -> bool:
        """Validate Docker compatibility checks."""
        docker_issues = [issue for issue in ubuntu_issues 
                        if 'docker' in issue['description'].lower() or 
                           'container' in issue['description'].lower()]
        
        # Docker compatibility is validated if we find Docker-related issues
        # or if there are no Docker files (which is also valid)
        docker_files_exist = any([
            (self.project_root / "docker-compose.yml").exists(),
            (self.project_root / "Dockerfile").exists(),
            (self.project_root / "Dockerfile.backend").exists()
        ])
        
        return len(docker_issues) > 0 or not docker_files_exist
    
    def _validate_network_security_checks(self, ubuntu_issues: List[Dict]) -> bool:
        """Validate network security checks."""
        network_issues = [issue for issue in ubuntu_issues 
                         if issue['type'] == 'network_security']
        
        # Check for network security patterns
        network_patterns = [
            'port',
            'network',
            'exposed',
            'security'
        ]
        
        found_patterns = set()
        for issue in network_issues:
            description = issue['description'].lower()
            for pattern in network_patterns:
                if pattern in description:
                    found_patterns.add(pattern)
        
        return len(found_patterns) > 0
    
    def _generate_test_summary(self):
        """Generate test summary."""
        print("\n" + "=" * 60)
        print("INTEGRATION TEST SUMMARY")
        print("=" * 60)
        
        total_tests = self.test_results['tests_run']
        passed_tests = self.test_results['tests_passed']
        failed_tests = self.test_results['tests_failed']
        
        print(f"Tests Run: {total_tests}")
        print(f"Tests Passed: {passed_tests}")
        print(f"Tests Failed: {failed_tests}")
        
        if failed_tests == 0:
            print("\n🟢 ALL TESTS PASSED - Security scanner is working correctly")
        else:
            print(f"\n🔴 {failed_tests} TESTS FAILED - Review issues above")
        
        # Print validation results
        if self.test_results['validation_results']:
            print(f"\nVALIDATION RESULTS:")
            for category, results in self.test_results['validation_results'].items():
                print(f"  {category.replace('_', ' ').title()}:")
                if isinstance(results, dict):
                    for key, value in results.items():
                        if isinstance(value, bool):
                            status = "✓" if value else "✗"
                            print(f"    {status} {key.replace('_', ' ').title()}")
                        else:
                            print(f"    - {key.replace('_', ' ').title()}: {value}")
        
        print("\n" + "=" * 60)

def main():
    """Main function to run integration tests."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Security Vulnerability Scanner Integration Test')
    parser.add_argument('--project-root', default='.', help='Project root directory')
    parser.add_argument('--output', help='Output file for test results (JSON format)')
    
    args = parser.parse_args()
    
    # Run integration tests
    tester = SecurityScannerIntegrationTest(args.project_root)
    results = tester.run_integration_tests()
    
    # Output results if requested
    if args.output:
        with open(args.output, 'w') as f:
            json.dump(results, f, indent=2)
        print(f"\nTest results written to {args.output}")
    
    # Return appropriate exit code
    return 0 if results['tests_failed'] == 0 else 1

if __name__ == '__main__':
    sys.exit(main())