#!/usr/bin/env python3
"""
Security Vulnerability Scanner Runner

This script runs comprehensive security vulnerability scanning and compliance checking
for the AI Scholar codebase with Ubuntu server compatibility focus.
"""

import os
import sys
import json
import argparse
import logging
from pathlib import Path
from datetime import datetime

# Add the scripts directory to the Python path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from security_vulnerability_scanner import SecurityVulnerabilityScanner

def setup_logging(verbose: bool = False):
    """Set up logging configuration."""
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout),
            logging.FileHandler('security_scan.log')
        ]
    )

def generate_report(results: dict, output_dir: Path):
    """Generate comprehensive security report."""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Generate JSON report
    json_report = output_dir / f"security_scan_report_{timestamp}.json"
    with open(json_report, 'w') as f:
        json.dump(results, f, indent=2)
    
    # Generate markdown report
    md_report = output_dir / f"security_scan_report_{timestamp}.md"
    generate_markdown_report(results, md_report)
    
    # Generate summary text
    summary_report = output_dir / f"security_scan_summary_{timestamp}.txt"
    generate_summary_report(results, summary_report)
    
    return {
        'json_report': json_report,
        'markdown_report': md_report,
        'summary_report': summary_report
    }

def generate_markdown_report(results: dict, output_file: Path):
    """Generate markdown format report."""
    summary = results['summary']
    issues = results['issues']
    recommendations = results['recommendations']
    
    with open(output_file, 'w') as f:
        f.write("# Security Vulnerability Scan Report\n\n")
        f.write(f"**Generated:** {summary['timestamp']}\n")
        f.write(f"**Project:** {summary['project_root']}\n\n")
        
        # Executive Summary
        f.write("## Executive Summary\n\n")
        f.write(f"- **Total Issues:** {summary['total_issues']}\n")
        f.write(f"- **Critical Issues:** {summary['critical_issues']}\n")
        f.write(f"- **High Severity Issues:** {summary['high_issues']}\n")
        f.write(f"- **Medium Severity Issues:** {summary['medium_issues']}\n")
        f.write(f"- **Low Severity Issues:** {summary['low_issues']}\n")
        f.write(f"- **Ubuntu-Specific Issues:** {summary['ubuntu_specific_issues']}\n")
        f.write(f"- **Auto-Fixable Issues:** {summary['auto_fixable_issues']}\n\n")
        
        # Risk Assessment
        f.write("## Risk Assessment\n\n")
        if summary['critical_issues'] > 0:
            f.write("ðŸ”´ **HIGH RISK** - Critical security vulnerabilities found\n\n")
        elif summary['high_issues'] > 5:
            f.write("ðŸŸ¡ **MEDIUM RISK** - Multiple high-severity issues found\n\n")
        else:
            f.write("ðŸŸ¢ **LOW RISK** - No critical vulnerabilities found\n\n")
        
        # Issues by Category
        f.write("## Issues by Category\n\n")
        
        categories = {}
        for issue in issues:
            category = issue['type']
            if category not in categories:
                categories[category] = []
            categories[category].append(issue)
        
        for category, category_issues in categories.items():
            f.write(f"### {category.replace('_', ' ').title()}\n\n")
            
            for issue in sorted(category_issues, key=lambda x: x['severity'], reverse=True):
                severity_emoji = {
                    'critical': 'ðŸ”´',
                    'high': 'ðŸŸ ',
                    'medium': 'ðŸŸ¡',
                    'low': 'ðŸŸ¢',
                    'info': 'ðŸ”µ'
                }.get(issue['severity'], 'âšª')
                
                f.write(f"#### {severity_emoji} {issue['id']}\n\n")
                f.write(f"**File:** `{issue['file_path']}`")
                if issue['line_number']:
                    f.write(f" (Line {issue['line_number']})")
                f.write("\n\n")
                f.write(f"**Description:** {issue['description']}\n\n")
                f.write(f"**Recommendation:** {issue['recommendation']}\n\n")
                
                if issue['ubuntu_specific']:
                    f.write("**Ubuntu-Specific:** Yes\n\n")
                
                if issue['auto_fixable']:
                    f.write("**Auto-Fixable:** Yes\n\n")
                
                if issue.get('cve_id'):
                    f.write(f"**CVE:** {issue['cve_id']}\n\n")
                
                f.write("---\n\n")
        
        # Recommendations
        f.write("## Recommendations\n\n")
        for i, recommendation in enumerate(recommendations, 1):
            f.write(f"{i}. {recommendation}\n")
        
        f.write("\n## Next Steps\n\n")
        f.write("1. Address all critical and high-severity issues immediately\n")
        f.write("2. Review and implement recommended security configurations\n")
        f.write("3. Set up automated security scanning in CI/CD pipeline\n")
        f.write("4. Establish regular security review processes\n")
        f.write("5. Monitor for new vulnerabilities in dependencies\n")

def generate_summary_report(results: dict, output_file: Path):
    """Generate summary text report."""
    summary = results['summary']
    issues = results['issues']
    
    with open(output_file, 'w') as f:
        f.write("SECURITY VULNERABILITY SCAN SUMMARY\n")
        f.write("=" * 50 + "\n\n")
        
        f.write(f"Scan Date: {summary['timestamp']}\n")
        f.write(f"Project: {summary['project_root']}\n\n")
        
        f.write("ISSUE SUMMARY:\n")
        f.write("-" * 20 + "\n")
        f.write(f"Total Issues: {summary['total_issues']}\n")
        f.write(f"Critical: {summary['critical_issues']}\n")
        f.write(f"High: {summary['high_issues']}\n")
        f.write(f"Medium: {summary['medium_issues']}\n")
        f.write(f"Low: {summary['low_issues']}\n")
        f.write(f"Ubuntu-Specific: {summary['ubuntu_specific_issues']}\n")
        f.write(f"Auto-Fixable: {summary['auto_fixable_issues']}\n\n")
        
        # Critical issues details
        if summary['critical_issues'] > 0:
            f.write("CRITICAL ISSUES:\n")
            f.write("-" * 20 + "\n")
            critical_issues = [issue for issue in issues if issue['severity'] == 'critical']
            for issue in critical_issues:
                f.write(f"- {issue['id']}: {issue['description']}\n")
                f.write(f"  File: {issue['file_path']}\n")
                f.write(f"  Fix: {issue['recommendation']}\n\n")
        
        # High priority Ubuntu-specific issues
        ubuntu_issues = [issue for issue in issues if issue['ubuntu_specific']]
        if ubuntu_issues:
            f.write("UBUNTU-SPECIFIC ISSUES:\n")
            f.write("-" * 25 + "\n")
            for issue in ubuntu_issues[:10]:  # Top 10
                f.write(f"- {issue['id']}: {issue['description']}\n")
                f.write(f"  Severity: {issue['severity'].upper()}\n\n")
        
        # Auto-fixable issues
        auto_fix_issues = [issue for issue in issues if issue['auto_fixable']]
        if auto_fix_issues:
            f.write("AUTO-FIXABLE ISSUES:\n")
            f.write("-" * 20 + "\n")
            for issue in auto_fix_issues[:10]:  # Top 10
                f.write(f"- {issue['id']}: {issue['description']}\n")

def print_scan_summary(results: dict):
    """Print scan summary to console."""
    summary = results['summary']
    
    print("\n" + "=" * 60)
    print("SECURITY VULNERABILITY SCAN RESULTS")
    print("=" * 60)
    
    print(f"\nProject: {summary['project_root']}")
    print(f"Scan Time: {summary['timestamp']}")
    
    print(f"\nISSUE SUMMARY:")
    print(f"  Total Issues: {summary['total_issues']}")
    print(f"  Critical: {summary['critical_issues']}")
    print(f"  High: {summary['high_issues']}")
    print(f"  Medium: {summary['medium_issues']}")
    print(f"  Low: {summary['low_issues']}")
    print(f"  Ubuntu-Specific: {summary['ubuntu_specific_issues']}")
    print(f"  Auto-Fixable: {summary['auto_fixable_issues']}")
    
    # Risk level
    if summary['critical_issues'] > 0:
        print(f"\nðŸ”´ RISK LEVEL: HIGH - {summary['critical_issues']} critical issues found")
    elif summary['high_issues'] > 5:
        print(f"\nðŸŸ¡ RISK LEVEL: MEDIUM - {summary['high_issues']} high-severity issues found")
    else:
        print(f"\nðŸŸ¢ RISK LEVEL: LOW - No critical vulnerabilities found")
    
    # Top recommendations
    recommendations = results['recommendations'][:5]
    if recommendations:
        print(f"\nTOP RECOMMENDATIONS:")
        for i, rec in enumerate(recommendations, 1):
            print(f"  {i}. {rec}")
    
    print("\n" + "=" * 60)

def main():
    """Main function."""
    parser = argparse.ArgumentParser(
        description='Run comprehensive security vulnerability scan',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python run_security_vulnerability_scan.py
  python run_security_vulnerability_scan.py --project-root /path/to/project
  python run_security_vulnerability_scan.py --output-dir ./security-reports --verbose
  python run_security_vulnerability_scan.py --json-only --output security_results.json
        """
    )
    
    parser.add_argument(
        '--project-root',
        default='.',
        help='Project root directory to scan (default: current directory)'
    )
    
    parser.add_argument(
        '--output-dir',
        type=Path,
        default=Path('./security-reports'),
        help='Output directory for reports (default: ./security-reports)'
    )
    
    parser.add_argument(
        '--json-only',
        action='store_true',
        help='Output only JSON results to stdout'
    )
    
    parser.add_argument(
        '--output',
        help='Specific output file for JSON results'
    )
    
    parser.add_argument(
        '--verbose',
        action='store_true',
        help='Enable verbose logging'
    )
    
    parser.add_argument(
        '--no-reports',
        action='store_true',
        help='Skip generating report files'
    )
    
    args = parser.parse_args()
    
    # Set up logging
    setup_logging(args.verbose)
    logger = logging.getLogger(__name__)
    
    try:
        # Initialize scanner
        logger.info(f"Starting security vulnerability scan for: {args.project_root}")
        scanner = SecurityVulnerabilityScanner(args.project_root)
        
        # Run comprehensive scan
        results = scanner.run_comprehensive_scan()
        
        # Handle output
        if args.json_only:
            print(json.dumps(results, indent=2))
        elif args.output:
            with open(args.output, 'w') as f:
                json.dump(results, f, indent=2)
            logger.info(f"Results written to {args.output}")
        else:
            # Generate reports
            if not args.no_reports:
                args.output_dir.mkdir(exist_ok=True)
                report_files = generate_report(results, args.output_dir)
                
                logger.info("Reports generated:")
                for report_type, report_file in report_files.items():
                    logger.info(f"  {report_type}: {report_file}")
            
            # Print summary
            print_scan_summary(results)
        
        # Return appropriate exit code
        summary = results['summary']
        if summary['critical_issues'] > 0:
            logger.warning(f"Scan completed with {summary['critical_issues']} critical issues")
            return 1
        elif summary['high_issues'] > 10:
            logger.warning(f"Scan completed with {summary['high_issues']} high-severity issues")
            return 1
        else:
            logger.info("Scan completed successfully")
            return 0
            
    except Exception as e:
        logger.error(f"Security scan failed: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1

if __name__ == '__main__':
    sys.exit(main())