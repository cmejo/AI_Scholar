#!/usr/bin/env python3
"""
Test suite for Security Vulnerability Scanner

This module tests the comprehensive security analysis functionality
for Ubuntu server compatibility and security best practices.
"""

import os
import sys
import json
import tempfile
import unittest
from pathlib import Path
from unittest.mock import patch, mock_open, MagicMock

# Add the scripts directory to the Python path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from security_vulnerability_scanner import (
    SecurityVulnerabilityScanner,
    SecurityIssue,
    SecuritySeverity,
    SecurityIssueType
)

class TestSecurityVulnerabilityScanner(unittest.TestCase):
    """Test cases for SecurityVulnerabilityScanner."""
    
    def setUp(self):
        """Set up test environment."""
        self.temp_dir = tempfile.mkdtemp()
        self.scanner = SecurityVulnerabilityScanner(self.temp_dir)
        
    def tearDown(self):
        """Clean up test environment."""
        import shutil
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_scanner_initialization(self):
        """Test scanner initialization."""
        self.assertIsInstance(self.scanner, SecurityVulnerabilityScanner)
        self.assertEqual(str(self.scanner.project_root), self.temp_dir)
        self.assertEqual(len(self.scanner.issues), 0)
        self.assertIn('timestamp', self.scanner.scan_results)
    
    def test_security_issue_creation(self):
        """Test SecurityIssue creation and serialization."""
        issue = SecurityIssue(
            id="TEST_001",
            type=SecurityIssueType.DEPENDENCY_VULNERABILITY,
            severity=SecuritySeverity.HIGH,
            file_path="test.py",
            line_number=10,
            description="Test vulnerability",
            recommendation="Fix the issue",
            ubuntu_specific=True,
            cve_id="CVE-2023-1234",
            auto_fixable=True
        )
        
        self.assertEqual(issue.id, "TEST_001")
        self.assertEqual(issue.severity, SecuritySeverity.HIGH)
        self.assertTrue(issue.ubuntu_specific)
        self.assertTrue(issue.auto_fixable)
        
        # Test serialization
        issue_dict = issue.to_dict()
        self.assertIsInstance(issue_dict, dict)
        self.assertEqual(issue_dict['id'], "TEST_001")
    
    def test_python_requirements_scanning(self):
        """Test Python requirements file scanning."""
        # Create test requirements file
        requirements_content = """
# Test requirements
requests==2.25.1
flask
django>=3.0.0
vulnerable-package==1.0.0
"""
        req_file = Path(self.temp_dir) / "requirements.txt"
        with open(req_file, 'w') as f:
            f.write(requirements_content)
        
        self.scanner._scan_python_requirements_file(req_file)
        
        # Should find unpinned dependencies
        unpinned_issues = [issue for issue in self.scanner.issues 
                          if issue.type == SecurityIssueType.DEPENDENCY_VULNERABILITY 
                          and "Unpinned dependency" in issue.description]
        
        self.assertGreater(len(unpinned_issues), 0)
        
        # Check that flask (unpinned) is flagged
        flask_issues = [issue for issue in unpinned_issues if "flask" in issue.description]
        self.assertGreater(len(flask_issues), 0)
    
    def test_package_json_scanning(self):
        """Test package.json file scanning."""
        # Create test package.json
        package_content = {
            "name": "test-app",
            "dependencies": {
                "react": "^17.0.0",
                "lodash": "*",
                "event-stream": "3.3.4"
            },
            "devDependencies": {
                "webpack": "~5.0.0"
            }
        }
        
        package_file = Path(self.temp_dir) / "package.json"
        with open(package_file, 'w') as f:
            json.dump(package_content, f)
        
        self.scanner._scan_package_json_file(package_file)
        
        # Should find flexible version ranges
        version_issues = [issue for issue in self.scanner.issues 
                         if "Flexible version range" in issue.description]
        self.assertGreater(len(version_issues), 0)
        
        # Should find known vulnerable packages
        vuln_issues = [issue for issue in self.scanner.issues 
                      if "Known vulnerable package" in issue.description]
        self.assertGreater(len(vuln_issues), 0)
    
    def test_file_permission_analysis(self):
        """Test file permission analysis."""
        # Create test files with different permissions
        test_file = Path(self.temp_dir) / "test_script.sh"
        with open(test_file, 'w') as f:
            f.write("#!/bin/bash\necho 'test'\n")
        
        # Make it world-writable (should be flagged)
        os.chmod(test_file, 0o666)
        
        self.scanner._check_file_permissions(test_file)
        
        # Should find world-writable file
        perm_issues = [issue for issue in self.scanner.issues 
                      if issue.type == SecurityIssueType.FILE_PERMISSION]
        self.assertGreater(len(perm_issues), 0)
    
    def test_sensitive_file_exposure(self):
        """Test sensitive file exposure detection."""
        # Create sensitive files
        sensitive_files = [".env", "id_rsa", "secret.key", "password.txt"]
        
        for filename in sensitive_files:
            test_file = Path(self.temp_dir) / filename
            with open(test_file, 'w') as f:
                f.write("sensitive content")
        
        # Mock gitignore check to return False (not ignored)
        with patch.object(self.scanner, '_is_gitignored', return_value=False):
            self.scanner._check_sensitive_file_exposure()
        
        # Should find sensitive files
        exposure_issues = [issue for issue in self.scanner.issues 
                          if issue.type == SecurityIssueType.SECRETS_EXPOSURE]
        self.assertGreater(len(exposure_issues), 0)
    
    def test_docker_compose_security_analysis(self):
        """Test Docker Compose security analysis."""
        # Create test docker-compose.yml
        compose_content = """
version: '3.8'
services:
  web:
    image: nginx:latest
    privileged: true
    network_mode: host
    ports:
      - "0.0.0.0:80:80"
    volumes:
      - "/etc:/etc:ro"
  
  db:
    image: postgres:13
    ports:
      - "5432:5432"
"""
        
        compose_file = Path(self.temp_dir) / "docker-compose.yml"
        with open(compose_file, 'w') as f:
            f.write(compose_content)
        
        self.scanner._analyze_docker_compose_security(compose_file)
        
        # Should find multiple security issues
        network_issues = [issue for issue in self.scanner.issues 
                         if issue.type == SecurityIssueType.NETWORK_SECURITY]
        self.assertGreater(len(network_issues), 0)
        
        # Check for specific issues
        privileged_issues = [issue for issue in network_issues 
                           if "privileged mode" in issue.description]
        self.assertGreater(len(privileged_issues), 0)
        
        host_network_issues = [issue for issue in network_issues 
                              if "host network mode" in issue.description]
        self.assertGreater(len(host_network_issues), 0)
    
    def test_nginx_config_analysis(self):
        """Test Nginx configuration analysis."""
        # Create test nginx.conf
        nginx_content = """
server {
    listen 80;
    server_name example.com;
    
    # Missing server_tokens off
    
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    
    location / {
        proxy_pass http://backend;
    }
}
"""
        
        nginx_file = Path(self.temp_dir) / "nginx.conf"
        with open(nginx_file, 'w') as f:
            f.write(nginx_content)
        
        self.scanner._analyze_nginx_config(nginx_file)
        
        # Should find security issues
        network_issues = [issue for issue in self.scanner.issues 
                         if issue.type == SecurityIssueType.NETWORK_SECURITY]
        
        # Check for old TLS versions
        tls_issues = [issue for issue in network_issues 
                     if "Old TLS versions" in issue.description]
        self.assertGreater(len(tls_issues), 0)
    
    def test_jwt_security_analysis(self):
        """Test JWT security analysis."""
        # Create test file with JWT code
        jwt_content = """
import jwt

# Weak secret
JWT_SECRET = "secret123"

def create_token(user_id):
    # Missing expiration
    token = jwt.encode({"user_id": user_id}, JWT_SECRET, algorithm="HS256")
    return token

def verify_token(token):
    return jwt.decode(token, JWT_SECRET, algorithms=["HS256"])
"""
        
        jwt_file = Path(self.temp_dir) / "auth.py"
        with open(jwt_file, 'w') as f:
            f.write(jwt_content)
        
        self.scanner._check_jwt_security()
        
        # Should find JWT security issues
        auth_issues = [issue for issue in self.scanner.issues 
                      if issue.type == SecurityIssueType.AUTHENTICATION]
        self.assertGreater(len(auth_issues), 0)
        
        # Check for weak secret
        weak_secret_issues = [issue for issue in auth_issues 
                             if "Weak or hardcoded JWT secret" in issue.description]
        self.assertGreater(len(weak_secret_issues), 0)
    
    def test_sql_injection_detection(self):
        """Test SQL injection vulnerability detection."""
        # Create test file with SQL injection vulnerability
        sql_content = """
def get_user(user_id):
    query = "SELECT * FROM users WHERE id = " + str(user_id)
    return execute_query(query)

def search_users(name):
    query = f"SELECT * FROM users WHERE name = '{name}'"
    return execute_query(query)
"""
        
        sql_file = Path(self.temp_dir) / "database.py"
        with open(sql_file, 'w') as f:
            f.write(sql_content)
        
        self.scanner._check_permission_validation()
        
        # Should find SQL injection vulnerabilities
        auth_issues = [issue for issue in self.scanner.issues 
                      if issue.type == SecurityIssueType.AUTHORIZATION]
        
        sql_injection_issues = [issue for issue in auth_issues 
                               if "SQL injection" in issue.description]
        self.assertGreater(len(sql_injection_issues), 0)
    
    def test_dangerous_function_detection(self):
        """Test dangerous function usage detection."""
        # Create test file with dangerous functions
        dangerous_content = """
import os
import subprocess

def execute_command(cmd):
    # Dangerous: direct system call
    os.system(cmd)
    
def run_script(script):
    # Dangerous: eval usage
    eval(script)
    
def process_data(data):
    # Dangerous: exec usage
    exec(data)
"""
        
        dangerous_file = Path(self.temp_dir) / "dangerous.py"
        with open(dangerous_file, 'w') as f:
            f.write(dangerous_content)
        
        self.scanner._check_privilege_escalation()
        
        # Should find dangerous function usage
        auth_issues = [issue for issue in self.scanner.issues 
                      if issue.type == SecurityIssueType.AUTHORIZATION]
        
        dangerous_func_issues = [issue for issue in auth_issues 
                                if "Dangerous function usage" in issue.description]
        self.assertGreater(len(dangerous_func_issues), 0)
    
    def test_environment_file_security(self):
        """Test environment file security analysis."""
        # Create test .env file
        env_content = """
# Database configuration
DB_PASSWORD=password123
API_SECRET=secret
JWT_SECRET=changeme
ADMIN_PASSWORD=admin

# Weak secret
ENCRYPTION_KEY=abc123

# Good secret (should not be flagged)
SECURE_KEY=a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6q7r8s9t0u1v2w3x4y5z6
"""
        
        env_file = Path(self.temp_dir) / ".env"
        with open(env_file, 'w') as f:
            f.write(env_content)
        
        self.scanner._check_environment_security()
        
        # Should find configuration issues
        config_issues = [issue for issue in self.scanner.issues 
                        if issue.type == SecurityIssueType.CONFIGURATION]
        self.assertGreater(len(config_issues), 0)
        
        # Check for weak secrets
        weak_secret_issues = [issue for issue in config_issues 
                             if "Weak secret value" in issue.description]
        self.assertGreater(len(weak_secret_issues), 0)
        
        # Check for default values
        default_value_issues = [issue for issue in config_issues 
                               if "Default/weak value" in issue.description]
        self.assertGreater(len(default_value_issues), 0)
    
    def test_dockerfile_security_analysis(self):
        """Test Dockerfile security analysis."""
        # Create test Dockerfile
        dockerfile_content = """
FROM ubuntu:latest

# Running as root (should be flagged)
USER root

# Using ADD instead of COPY (should be flagged)
ADD app.tar.gz /app/

# Good practice
COPY requirements.txt /app/
RUN pip install -r /app/requirements.txt

EXPOSE 8000
CMD ["python", "app.py"]
"""
        
        dockerfile = Path(self.temp_dir) / "Dockerfile"
        with open(dockerfile, 'w') as f:
            f.write(dockerfile_content)
        
        self.scanner._analyze_dockerfile_security(dockerfile)
        
        # Should find configuration issues
        config_issues = [issue for issue in self.scanner.issues 
                        if issue.type == SecurityIssueType.CONFIGURATION]
        self.assertGreater(len(config_issues), 0)
        
        # Check for specific issues
        root_issues = [issue for issue in config_issues 
                      if "root user" in issue.description]
        self.assertGreater(len(root_issues), 0)
        
        add_issues = [issue for issue in config_issues 
                     if "ADD instead of COPY" in issue.description]
        self.assertGreater(len(add_issues), 0)
        
        latest_issues = [issue for issue in config_issues 
                        if "latest" in issue.description]
        self.assertGreater(len(latest_issues), 0)
    
    def test_secrets_exposure_detection(self):
        """Test secrets exposure detection."""
        # Create test file with potential secrets
        secrets_content = """
# Configuration file
API_KEY = "sk-1234567890abcdef1234567890abcdef12345678"
SLACK_TOKEN = "xoxb-1234567890-1234567890123-abcdefghijklmnopqrstuvwx"
GITHUB_TOKEN = "ghp_1234567890abcdef1234567890abcdef123456"

# Not a secret (should not be flagged)
EXAMPLE_KEY = "your_api_key_here"
TEST_HASH = "d41d8cd98f00b204e9800998ecf8427e"  # MD5 of empty string
"""
        
        secrets_file = Path(self.temp_dir) / "config.py"
        with open(secrets_file, 'w') as f:
            f.write(secrets_content)
        
        self.scanner._check_secrets_exposure()
        
        # Should find secrets exposure
        secrets_issues = [issue for issue in self.scanner.issues 
                         if issue.type == SecurityIssueType.SECRETS_EXPOSURE]
        self.assertGreater(len(secrets_issues), 0)
        
        # Check for specific secret types
        openai_issues = [issue for issue in secrets_issues 
                        if "OpenAI API key" in issue.description]
        self.assertGreater(len(openai_issues), 0)
    
    @patch('subprocess.run')
    def test_safety_scan_integration(self, mock_subprocess):
        """Test safety vulnerability scanner integration."""
        # Mock safety command output
        mock_result = MagicMock()
        mock_result.returncode = 1  # Vulnerabilities found
        mock_result.stdout = json.dumps([
            {
                "id": "12345",
                "package": "requests",
                "installed_version": "2.20.0",
                "safe_version": "2.20.1",
                "severity": "high",
                "cve": "CVE-2018-18074"
            }
        ])
        mock_subprocess.return_value = mock_result
        
        self.scanner._run_safety_scan()
        
        # Should find vulnerability from safety
        safety_issues = [issue for issue in self.scanner.issues 
                        if issue.id.startswith("SAFETY_")]
        self.assertGreater(len(safety_issues), 0)
        
        # Check issue details
        issue = safety_issues[0]
        self.assertEqual(issue.severity, SecuritySeverity.HIGH)
        self.assertEqual(issue.cve_id, "CVE-2018-18074")
        self.assertTrue(issue.auto_fixable)
    
    def test_comprehensive_scan_integration(self):
        """Test comprehensive scan integration."""
        # Create a minimal project structure
        (Path(self.temp_dir) / "requirements.txt").write_text("flask\nrequests==2.25.1")
        (Path(self.temp_dir) / "package.json").write_text('{"dependencies": {"lodash": "*"}}')
        (Path(self.temp_dir) / ".env").write_text("SECRET_KEY=weak")
        
        # Run comprehensive scan
        results = self.scanner.run_comprehensive_scan()
        
        # Verify results structure
        self.assertIn('summary', results)
        self.assertIn('issues', results)
        self.assertIn('recommendations', results)
        
        # Verify summary statistics
        summary = results['summary']
        self.assertIn('total_issues', summary)
        self.assertIn('critical_issues', summary)
        self.assertIn('ubuntu_specific_issues', summary)
        
        # Should have found some issues
        self.assertGreater(summary['total_issues'], 0)
        
        # Verify recommendations
        recommendations = results['recommendations']
        self.assertIsInstance(recommendations, list)
        self.assertGreater(len(recommendations), 0)
    
    def test_gitignore_check(self):
        """Test .gitignore file checking."""
        # Create .gitignore file
        gitignore_content = """
.env
*.key
node_modules/
__pycache__/
"""
        gitignore_file = Path(self.temp_dir) / ".gitignore"
        with open(gitignore_file, 'w') as f:
            f.write(gitignore_content)
        
        # Test files
        env_file = Path(self.temp_dir) / ".env"
        key_file = Path(self.temp_dir) / "secret.key"
        normal_file = Path(self.temp_dir) / "app.py"
        
        # Test gitignore checking
        self.assertTrue(self.scanner._is_gitignored(env_file))
        self.assertTrue(self.scanner._is_gitignored(key_file))
        self.assertFalse(self.scanner._is_gitignored(normal_file))
    
    def test_secret_detection_accuracy(self):
        """Test accuracy of secret detection."""
        # Test cases for secret detection
        test_cases = [
            ("sk-1234567890abcdef1234567890abcdef12345678", "API_KEY = ", True),  # Real secret
            ("your_api_key_here", "API_KEY = ", False),  # Placeholder
            ("example_secret_key", "SECRET = ", False),  # Example
            ("a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6", "TOKEN = ", True),  # Real token
            ("0000000000000000000000000000000000000000", "HASH = ", False),  # All zeros
            ("d41d8cd98f00b204e9800998ecf8427e", "# MD5 hash", False),  # Comment
        ]
        
        for secret, line_context, should_detect in test_cases:
            full_line = line_context + secret
            result = self.scanner._is_likely_secret(secret, full_line)
            self.assertEqual(result, should_detect, 
                           f"Failed for secret: {secret} in context: {line_context}")

class TestSecurityScannerCLI(unittest.TestCase):
    """Test CLI functionality of security scanner."""
    
    def test_main_function_help(self):
        """Test main function with help argument."""
        with patch('sys.argv', ['security_vulnerability_scanner.py', '--help']):
            with self.assertRaises(SystemExit) as cm:
                from security_vulnerability_scanner import main
                main()
            # Help should exit with code 0
            self.assertEqual(cm.exception.code, 0)
    
    @patch('builtins.print')
    @patch('json.dump')
    def test_main_function_output(self, mock_json_dump, mock_print):
        """Test main function output functionality."""
        with tempfile.TemporaryDirectory() as temp_dir:
            with patch('sys.argv', [
                'security_vulnerability_scanner.py', 
                '--project-root', temp_dir,
                '--output', 'test_output.json'
            ]):
                from security_vulnerability_scanner import main
                result = main()
                
                # Should complete successfully
                self.assertIn(result, [0, 1])  # 0 for no critical issues, 1 for critical issues
                
                # Should have called json.dump for output file
                mock_json_dump.assert_called_once()

def run_security_scanner_tests():
    """Run all security scanner tests."""
    # Create test loader
    loader = unittest.TestLoader()
    
    # Create test suite
    test_suite = unittest.TestSuite()
    
    # Add test cases
    test_suite.addTests(loader.loadTestsFromTestCase(TestSecurityVulnerabilityScanner))
    test_suite.addTests(loader.loadTestsFromTestCase(TestSecurityScannerCLI))
    
    # Run tests
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(test_suite)
    
    return result.wasSuccessful()

if __name__ == '__main__':
    success = run_security_scanner_tests()
    sys.exit(0 if success else 1)