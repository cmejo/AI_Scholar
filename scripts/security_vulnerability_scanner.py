#!/usr/bin/env python3
"""
Security Vulnerability Scanner and Compliance Checker

This module provides comprehensive security analysis for the AI Scholar codebase,
focusing on Ubuntu server compatibility and security best practices.
"""

import os
import sys
import json
import subprocess
import logging
import re
import stat
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict
from enum import Enum
import yaml
from datetime import datetime

try:
    import requests
    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class SecuritySeverity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class SecurityIssueType(Enum):
    DEPENDENCY_VULNERABILITY = "dependency_vulnerability"
    FILE_PERMISSION = "file_permission"
    NETWORK_SECURITY = "network_security"
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    CONFIGURATION = "configuration"
    SECRETS_EXPOSURE = "secrets_exposure"

@dataclass
class SecurityIssue:
    id: str
    type: SecurityIssueType
    severity: SecuritySeverity
    file_path: str
    line_number: Optional[int]
    description: str
    recommendation: str
    ubuntu_specific: bool
    cve_id: Optional[str] = None
    cvss_score: Optional[float] = None
    auto_fixable: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        result = asdict(self)
        # Convert enums to strings for JSON serialization
        result['type'] = self.type.value
        result['severity'] = self.severity.value
        return result

class SecurityVulnerabilityScanner:
    """Main security vulnerability scanner and compliance checker."""
    
    def __init__(self, project_root: str = "."):
        self.project_root = Path(project_root).resolve()
        self.issues: List[SecurityIssue] = []
        self.scan_results = {
            'timestamp': datetime.now().isoformat(),
            'project_root': str(self.project_root),
            'total_issues': 0,
            'critical_issues': 0,
            'high_issues': 0,
            'medium_issues': 0,
            'low_issues': 0,
            'ubuntu_specific_issues': 0,
            'auto_fixable_issues': 0
        }
        
    def run_comprehensive_scan(self) -> Dict[str, Any]:
        """Run all security scans and return comprehensive results."""
        logger.info("Starting comprehensive security vulnerability scan...")
        
        try:
            # 1. Dependency vulnerability scanning
            self._scan_python_dependencies()
            self._scan_nodejs_dependencies()
            
            # 2. File permission and access control analysis
            self._analyze_file_permissions()
            self._check_sensitive_file_exposure()
            
            # 3. Network security configuration validation
            self._validate_network_configurations()
            self._check_exposed_services()
            
            # 4. Authentication and authorization audit
            self._audit_authentication_mechanisms()
            self._audit_authorization_controls()
            
            # 5. Configuration security analysis
            self._analyze_security_configurations()
            self._check_secrets_exposure()
            
            # Generate summary statistics
            self._generate_summary_stats()
            
            logger.info(f"Security scan completed. Found {len(self.issues)} total issues.")
            
        except Exception as e:
            logger.error(f"Error during security scan: {e}")
            self.issues.append(SecurityIssue(
                id="SCAN_ERROR_001",
                type=SecurityIssueType.CONFIGURATION,
                severity=SecuritySeverity.HIGH,
                file_path="scanner",
                line_number=None,
                description=f"Security scan failed: {str(e)}",
                recommendation="Review scanner configuration and dependencies",
                ubuntu_specific=False
            ))
        
        return self._format_results()
    
    def _scan_python_dependencies(self):
        """Scan Python dependencies for known vulnerabilities."""
        logger.info("Scanning Python dependencies for vulnerabilities...")
        
        # Check for requirements files
        req_files = [
            self.project_root / "requirements.txt",
            self.project_root / "backend" / "requirements.txt",
            self.project_root / "backend" / "requirements-dev.txt"
        ]
        
        for req_file in req_files:
            if req_file.exists():
                self._scan_python_requirements_file(req_file)
        
        # Scan using safety if available
        self._run_safety_scan()
        
        # Scan using pip-audit if available
        self._run_pip_audit_scan()
    
    def _scan_python_requirements_file(self, req_file: Path):
        """Scan a specific Python requirements file."""
        try:
            with open(req_file, 'r') as f:
                content = f.read()
            
            # Check for unpinned dependencies
            lines = content.strip().split('\n')
            for i, line in enumerate(lines, 1):
                line = line.strip()
                if line and not line.startswith('#'):
                    if '==' not in line and '>=' not in line and '<=' not in line:
                        self.issues.append(SecurityIssue(
                            id=f"PY_DEP_{req_file.name}_{i}",
                            type=SecurityIssueType.DEPENDENCY_VULNERABILITY,
                            severity=SecuritySeverity.MEDIUM,
                            file_path=str(req_file.relative_to(self.project_root)),
                            line_number=i,
                            description=f"Unpinned dependency: {line}",
                            recommendation="Pin dependency versions to ensure reproducible builds",
                            ubuntu_specific=False,
                            auto_fixable=True
                        ))
            
        except Exception as e:
            logger.error(f"Error scanning {req_file}: {e}")
    
    def _run_safety_scan(self):
        """Run safety vulnerability scanner if available."""
        try:
            result = subprocess.run(
                ['safety', 'check', '--json'],
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                # No vulnerabilities found
                logger.info("Safety scan completed - no vulnerabilities found")
            else:
                # Parse safety output
                try:
                    safety_data = json.loads(result.stdout)
                    for vuln in safety_data:
                        self.issues.append(SecurityIssue(
                            id=f"SAFETY_{vuln.get('id', 'UNKNOWN')}",
                            type=SecurityIssueType.DEPENDENCY_VULNERABILITY,
                            severity=self._map_safety_severity(vuln.get('severity', 'medium')),
                            file_path="requirements.txt",
                            line_number=None,
                            description=f"Vulnerable package: {vuln.get('package')} {vuln.get('installed_version')}",
                            recommendation=f"Update to version {vuln.get('safe_version', 'latest')}",
                            ubuntu_specific=False,
                            cve_id=vuln.get('cve'),
                            auto_fixable=True
                        ))
                except json.JSONDecodeError:
                    logger.warning("Could not parse safety output")
                    
        except FileNotFoundError:
            logger.info("Safety not installed - skipping Python vulnerability scan")
        except subprocess.TimeoutExpired:
            logger.warning("Safety scan timed out")
        except Exception as e:
            logger.error(f"Error running safety scan: {e}")
    
    def _run_pip_audit_scan(self):
        """Run pip-audit vulnerability scanner if available."""
        try:
            result = subprocess.run(
                ['pip-audit', '--format=json'],
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=120
            )
            
            if result.returncode == 0:
                try:
                    audit_data = json.loads(result.stdout)
                    for vuln in audit_data.get('vulnerabilities', []):
                        self.issues.append(SecurityIssue(
                            id=f"AUDIT_{vuln.get('id', 'UNKNOWN')}",
                            type=SecurityIssueType.DEPENDENCY_VULNERABILITY,
                            severity=self._map_cvss_to_severity(vuln.get('fix', {}).get('versions', [])),
                            file_path="Python dependencies",
                            line_number=None,
                            description=f"Vulnerable package: {vuln.get('package')} {vuln.get('installed_version')}",
                            recommendation=f"Update to fixed version: {', '.join(vuln.get('fix', {}).get('versions', []))}",
                            ubuntu_specific=False,
                            cve_id=vuln.get('id'),
                            auto_fixable=True
                        ))
                except json.JSONDecodeError:
                    logger.warning("Could not parse pip-audit output")
                    
        except FileNotFoundError:
            logger.info("pip-audit not installed - skipping enhanced Python vulnerability scan")
        except subprocess.TimeoutExpired:
            logger.warning("pip-audit scan timed out")
        except Exception as e:
            logger.error(f"Error running pip-audit scan: {e}") 
   
    def _scan_nodejs_dependencies(self):
        """Scan Node.js dependencies for known vulnerabilities."""
        logger.info("Scanning Node.js dependencies for vulnerabilities...")
        
        # Check for package.json files
        package_files = [
            self.project_root / "package.json",
            self.project_root / "frontend" / "package.json"
        ]
        
        for package_file in package_files:
            if package_file.exists():
                self._scan_package_json_file(package_file)
        
        # Run npm audit if available
        self._run_npm_audit_scan()
    
    def _scan_package_json_file(self, package_file: Path):
        """Scan a specific package.json file."""
        try:
            with open(package_file, 'r') as f:
                package_data = json.load(f)
            
            # Check dependencies for known vulnerable patterns
            deps = package_data.get('dependencies', {})
            dev_deps = package_data.get('devDependencies', {})
            
            all_deps = {**deps, **dev_deps}
            
            for dep_name, version in all_deps.items():
                # Check for wildcard versions
                if version.startswith('^') or version.startswith('~') or version == '*':
                    self.issues.append(SecurityIssue(
                        id=f"NPM_DEP_{dep_name}",
                        type=SecurityIssueType.DEPENDENCY_VULNERABILITY,
                        severity=SecuritySeverity.LOW,
                        file_path=str(package_file.relative_to(self.project_root)),
                        line_number=None,
                        description=f"Flexible version range for {dep_name}: {version}",
                        recommendation="Consider pinning to specific versions for production",
                        ubuntu_specific=False,
                        auto_fixable=True
                    ))
                
                # Check for known vulnerable packages
                if dep_name in self._get_known_vulnerable_npm_packages():
                    self.issues.append(SecurityIssue(
                        id=f"NPM_VULN_{dep_name}",
                        type=SecurityIssueType.DEPENDENCY_VULNERABILITY,
                        severity=SecuritySeverity.HIGH,
                        file_path=str(package_file.relative_to(self.project_root)),
                        line_number=None,
                        description=f"Known vulnerable package: {dep_name}",
                        recommendation="Update to latest secure version or find alternative",
                        ubuntu_specific=False,
                        auto_fixable=True
                    ))
            
        except Exception as e:
            logger.error(f"Error scanning {package_file}: {e}")
    
    def _run_npm_audit_scan(self):
        """Run npm audit vulnerability scanner if available."""
        try:
            result = subprocess.run(
                ['npm', 'audit', '--json'],
                cwd=self.project_root,
                capture_output=True,
                text=True,
                timeout=120
            )
            
            if result.stdout:
                try:
                    audit_data = json.loads(result.stdout)
                    vulnerabilities = audit_data.get('vulnerabilities', {})
                    
                    for vuln_name, vuln_data in vulnerabilities.items():
                        severity = vuln_data.get('severity', 'medium')
                        self.issues.append(SecurityIssue(
                            id=f"NPM_AUDIT_{vuln_name}",
                            type=SecurityIssueType.DEPENDENCY_VULNERABILITY,
                            severity=self._map_npm_severity(severity),
                            file_path="package.json",
                            line_number=None,
                            description=f"Vulnerable npm package: {vuln_name}",
                            recommendation=f"Run 'npm audit fix' or update manually",
                            ubuntu_specific=False,
                            auto_fixable=True
                        ))
                        
                except json.JSONDecodeError:
                    logger.warning("Could not parse npm audit output")
                    
        except FileNotFoundError:
            logger.info("npm not installed - skipping Node.js vulnerability scan")
        except subprocess.TimeoutExpired:
            logger.warning("npm audit scan timed out")
        except Exception as e:
            logger.error(f"Error running npm audit scan: {e}")
    
    def _analyze_file_permissions(self):
        """Analyze file permissions for Ubuntu compatibility and security."""
        logger.info("Analyzing file permissions and access controls...")
        
        # Check critical files and directories
        critical_paths = [
            "backend/app.py",
            "backend/config",
            ".env",
            ".env.production",
            "docker-compose.yml",
            "docker-compose.prod.yml",
            "scripts",
            "ssl",
            "config"
        ]
        
        for path_str in critical_paths:
            path = self.project_root / path_str
            if path.exists():
                self._check_file_permissions(path)
        
        # Check for world-writable files
        self._find_world_writable_files()
        
        # Check for executable files without proper permissions
        self._check_executable_permissions()
    
    def _check_file_permissions(self, path: Path):
        """Check permissions for a specific file or directory."""
        try:
            file_stat = path.stat()
            mode = file_stat.st_mode
            
            # Check for overly permissive permissions
            if stat.S_ISREG(mode):  # Regular file
                if mode & stat.S_IWOTH:  # World writable
                    self.issues.append(SecurityIssue(
                        id=f"PERM_WORLD_WRITE_{path.name}",
                        type=SecurityIssueType.FILE_PERMISSION,
                        severity=SecuritySeverity.HIGH,
                        file_path=str(path.relative_to(self.project_root)),
                        line_number=None,
                        description=f"File is world-writable: {path}",
                        recommendation="Remove world-write permissions: chmod o-w",
                        ubuntu_specific=True,
                        auto_fixable=True
                    ))
                
                # Check for sensitive files with read permissions for others
                if path.name.startswith('.env') or 'secret' in path.name.lower():
                    if mode & stat.S_IROTH:  # World readable
                        self.issues.append(SecurityIssue(
                            id=f"PERM_SENSITIVE_READ_{path.name}",
                            type=SecurityIssueType.FILE_PERMISSION,
                            severity=SecuritySeverity.MEDIUM,
                            file_path=str(path.relative_to(self.project_root)),
                            line_number=None,
                            description=f"Sensitive file is world-readable: {path}",
                            recommendation="Restrict read permissions: chmod 600",
                            ubuntu_specific=True,
                            auto_fixable=True
                        ))
            
            elif stat.S_ISDIR(mode):  # Directory
                if mode & stat.S_IWOTH:  # World writable directory
                    self.issues.append(SecurityIssue(
                        id=f"PERM_DIR_WORLD_WRITE_{path.name}",
                        type=SecurityIssueType.FILE_PERMISSION,
                        severity=SecuritySeverity.HIGH,
                        file_path=str(path.relative_to(self.project_root)),
                        line_number=None,
                        description=f"Directory is world-writable: {path}",
                        recommendation="Remove world-write permissions: chmod o-w",
                        ubuntu_specific=True,
                        auto_fixable=True
                    ))
                    
        except Exception as e:
            logger.error(f"Error checking permissions for {path}: {e}")
    
    def _find_world_writable_files(self):
        """Find all world-writable files in the project."""
        try:
            for root, dirs, files in os.walk(self.project_root):
                # Skip hidden directories and common ignore patterns
                dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['node_modules', '__pycache__', 'venv']]
                
                for file in files:
                    file_path = Path(root) / file
                    try:
                        file_stat = file_path.stat()
                        if file_stat.st_mode & stat.S_IWOTH:
                            self.issues.append(SecurityIssue(
                                id=f"WORLD_WRITE_{file}",
                                type=SecurityIssueType.FILE_PERMISSION,
                                severity=SecuritySeverity.MEDIUM,
                                file_path=str(file_path.relative_to(self.project_root)),
                                line_number=None,
                                description=f"World-writable file found: {file}",
                                recommendation="Remove world-write permissions",
                                ubuntu_specific=True,
                                auto_fixable=True
                            ))
                    except Exception:
                        continue
                        
        except Exception as e:
            logger.error(f"Error finding world-writable files: {e}")
    
    def _check_executable_permissions(self):
        """Check for proper executable permissions on scripts."""
        script_extensions = ['.sh', '.py', '.js']
        script_dirs = ['scripts', 'bin']
        
        for script_dir in script_dirs:
            script_path = self.project_root / script_dir
            if script_path.exists():
                for file_path in script_path.rglob('*'):
                    if file_path.is_file():
                        # Check if it should be executable
                        should_be_executable = (
                            file_path.suffix in script_extensions or
                            file_path.name.endswith('.sh') or
                            self._has_shebang(file_path)
                        )
                        
                        if should_be_executable:
                            file_stat = file_path.stat()
                            if not (file_stat.st_mode & stat.S_IXUSR):
                                self.issues.append(SecurityIssue(
                                    id=f"EXEC_PERM_{file_path.name}",
                                    type=SecurityIssueType.FILE_PERMISSION,
                                    severity=SecuritySeverity.LOW,
                                    file_path=str(file_path.relative_to(self.project_root)),
                                    line_number=None,
                                    description=f"Script file not executable: {file_path.name}",
                                    recommendation="Add execute permissions: chmod +x",
                                    ubuntu_specific=True,
                                    auto_fixable=True
                                ))
    
    def _has_shebang(self, file_path: Path) -> bool:
        """Check if file has a shebang line."""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                first_line = f.readline().strip()
                return first_line.startswith('#!')
        except Exception:
            return False  
  
    def _check_sensitive_file_exposure(self):
        """Check for sensitive files that might be exposed."""
        sensitive_patterns = [
            r'\.env',
            r'\.key$',
            r'\.pem$',
            r'\.p12$',
            r'\.pfx$',
            r'id_rsa',
            r'id_dsa',
            r'\.ssh',
            r'password',
            r'secret',
            r'token',
            r'api_key'
        ]
        
        for root, dirs, files in os.walk(self.project_root):
            # Skip hidden directories and common ignore patterns
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['node_modules', '__pycache__', 'venv']]
            
            for file in files:
                file_lower = file.lower()
                for pattern in sensitive_patterns:
                    if re.search(pattern, file_lower):
                        file_path = Path(root) / file
                        
                        # Check if it's in .gitignore
                        if not self._is_gitignored(file_path):
                            self.issues.append(SecurityIssue(
                                id=f"SENSITIVE_EXPOSE_{file}",
                                type=SecurityIssueType.SECRETS_EXPOSURE,
                                severity=SecuritySeverity.HIGH,
                                file_path=str(file_path.relative_to(self.project_root)),
                                line_number=None,
                                description=f"Potentially sensitive file not in .gitignore: {file}",
                                recommendation="Add to .gitignore or move to secure location",
                                ubuntu_specific=False,
                                auto_fixable=False
                            ))
                        break
    
    def _validate_network_configurations(self):
        """Validate network security configurations."""
        logger.info("Validating network security configurations...")
        
        # Check Docker Compose network configurations
        self._check_docker_network_security()
        
        # Check Nginx configurations
        self._check_nginx_security()
        
        # Check exposed ports
        self._check_port_configurations()
    
    def _check_docker_network_security(self):
        """Check Docker network security configurations."""
        docker_compose_files = [
            "docker-compose.yml",
            "docker-compose.prod.yml",
            "docker-compose.blue.yml",
            "docker-compose.green.yml"
        ]
        
        for compose_file in docker_compose_files:
            compose_path = self.project_root / compose_file
            if compose_path.exists():
                self._analyze_docker_compose_security(compose_path)
    
    def _analyze_docker_compose_security(self, compose_path: Path):
        """Analyze Docker Compose file for security issues."""
        try:
            with open(compose_path, 'r') as f:
                compose_data = yaml.safe_load(f)
            
            services = compose_data.get('services', {})
            
            for service_name, service_config in services.items():
                # Check for privileged containers
                if service_config.get('privileged', False):
                    self.issues.append(SecurityIssue(
                        id=f"DOCKER_PRIVILEGED_{service_name}",
                        type=SecurityIssueType.NETWORK_SECURITY,
                        severity=SecuritySeverity.HIGH,
                        file_path=str(compose_path.relative_to(self.project_root)),
                        line_number=None,
                        description=f"Service running in privileged mode: {service_name}",
                        recommendation="Remove privileged mode unless absolutely necessary",
                        ubuntu_specific=False,
                        auto_fixable=False
                    ))
                
                # Check for host network mode
                if service_config.get('network_mode') == 'host':
                    self.issues.append(SecurityIssue(
                        id=f"DOCKER_HOST_NETWORK_{service_name}",
                        type=SecurityIssueType.NETWORK_SECURITY,
                        severity=SecuritySeverity.MEDIUM,
                        file_path=str(compose_path.relative_to(self.project_root)),
                        line_number=None,
                        description=f"Service using host network mode: {service_name}",
                        recommendation="Use bridge network mode for better isolation",
                        ubuntu_specific=True,
                        auto_fixable=False
                    ))
                
                # Check for exposed ports
                ports = service_config.get('ports', [])
                for port in ports:
                    if isinstance(port, str) and ':' in port:
                        host_port, container_port = port.split(':')
                        if host_port.startswith('0.0.0.0'):
                            self.issues.append(SecurityIssue(
                                id=f"DOCKER_EXPOSE_ALL_{service_name}_{host_port}",
                                type=SecurityIssueType.NETWORK_SECURITY,
                                severity=SecuritySeverity.MEDIUM,
                                file_path=str(compose_path.relative_to(self.project_root)),
                                line_number=None,
                                description=f"Port exposed on all interfaces: {port}",
                                recommendation="Bind to localhost (127.0.0.1) if external access not needed",
                                ubuntu_specific=False,
                                auto_fixable=True
                            ))
                
                # Check for volume mounts
                volumes = service_config.get('volumes', [])
                for volume in volumes:
                    if isinstance(volume, str) and ':' in volume:
                        parts = volume.split(':', 2)  # Handle cases with multiple colons
                        if len(parts) >= 2:
                            host_path = parts[0]
                            if host_path.startswith('/'):
                                # Absolute path mount
                                if any(sensitive in host_path.lower() for sensitive in ['etc', 'root', 'home']):
                                    self.issues.append(SecurityIssue(
                                        id=f"DOCKER_SENSITIVE_MOUNT_{service_name}",
                                        type=SecurityIssueType.NETWORK_SECURITY,
                                        severity=SecuritySeverity.HIGH,
                                        file_path=str(compose_path.relative_to(self.project_root)),
                                        line_number=None,
                                        description=f"Sensitive directory mounted: {host_path}",
                                        recommendation="Avoid mounting sensitive system directories",
                                        ubuntu_specific=True,
                                        auto_fixable=False
                                    ))
                            
        except Exception as e:
            logger.error(f"Error analyzing Docker Compose file {compose_path}: {e}")
    
    def _check_nginx_security(self):
        """Check Nginx security configurations."""
        nginx_configs = [
            "nginx.conf",
            "config/nginx.conf",
            "config/nginx.prod.conf"
        ]
        
        for config_file in nginx_configs:
            config_path = self.project_root / config_file
            if config_path.exists():
                self._analyze_nginx_config(config_path)
    
    def _analyze_nginx_config(self, config_path: Path):
        """Analyze Nginx configuration for security issues."""
        try:
            with open(config_path, 'r') as f:
                content = f.read()
            
            lines = content.split('\n')
            
            for i, line in enumerate(lines, 1):
                line = line.strip()
                
                # Check for server tokens
                if 'server_tokens' in line and 'off' not in line:
                    self.issues.append(SecurityIssue(
                        id=f"NGINX_SERVER_TOKENS_{i}",
                        type=SecurityIssueType.NETWORK_SECURITY,
                        severity=SecuritySeverity.LOW,
                        file_path=str(config_path.relative_to(self.project_root)),
                        line_number=i,
                        description="Nginx server tokens not disabled",
                        recommendation="Add 'server_tokens off;' to hide version information",
                        ubuntu_specific=False,
                        auto_fixable=True
                    ))
                
                # Check for SSL/TLS configuration
                if 'ssl_protocols' in line:
                    if 'TLSv1' in line and 'TLSv1.3' not in line:
                        self.issues.append(SecurityIssue(
                            id=f"NGINX_OLD_TLS_{i}",
                            type=SecurityIssueType.NETWORK_SECURITY,
                            severity=SecuritySeverity.MEDIUM,
                            file_path=str(config_path.relative_to(self.project_root)),
                            line_number=i,
                            description="Old TLS versions enabled",
                            recommendation="Use only TLSv1.2 and TLSv1.3",
                            ubuntu_specific=False,
                            auto_fixable=True
                        ))
                
                # Check for security headers
                security_headers = [
                    'X-Frame-Options',
                    'X-Content-Type-Options',
                    'X-XSS-Protection',
                    'Strict-Transport-Security'
                ]
                
                if 'add_header' in line:
                    for header in security_headers:
                        if header in line:
                            break
                    else:
                        # No security headers found in this add_header directive
                        pass
                        
        except Exception as e:
            logger.error(f"Error analyzing Nginx config {config_path}: {e}")
    
    def _check_port_configurations(self):
        """Check for insecure port configurations."""
        # Common insecure ports that should not be exposed
        insecure_ports = {
            '21': 'FTP',
            '23': 'Telnet',
            '25': 'SMTP',
            '53': 'DNS',
            '80': 'HTTP (consider HTTPS)',
            '110': 'POP3',
            '143': 'IMAP',
            '993': 'IMAPS',
            '995': 'POP3S'
        }
        
        # Check Docker Compose files for exposed ports
        for compose_file in ['docker-compose.yml', 'docker-compose.prod.yml']:
            compose_path = self.project_root / compose_file
            if compose_path.exists():
                try:
                    with open(compose_path, 'r') as f:
                        content = f.read()
                    
                    for port, service in insecure_ports.items():
                        if f':{port}' in content or f'"{port}:' in content:
                            self.issues.append(SecurityIssue(
                                id=f"INSECURE_PORT_{port}",
                                type=SecurityIssueType.NETWORK_SECURITY,
                                severity=SecuritySeverity.MEDIUM,
                                file_path=str(compose_path.relative_to(self.project_root)),
                                line_number=None,
                                description=f"Potentially insecure port exposed: {port} ({service})",
                                recommendation=f"Review necessity of exposing {service} port",
                                ubuntu_specific=False,
                                auto_fixable=False
                            ))
                            
                except Exception as e:
                    logger.error(f"Error checking ports in {compose_path}: {e}")
    
    def _check_exposed_services(self):
        """Check for services that might be unnecessarily exposed."""
        # Services that should typically not be exposed externally
        internal_services = [
            'redis',
            'postgres',
            'postgresql',
            'mysql',
            'mongodb',
            'elasticsearch',
            'chromadb'
        ]
        
        compose_files = ['docker-compose.yml', 'docker-compose.prod.yml']
        
        for compose_file in compose_files:
            compose_path = self.project_root / compose_file
            if compose_path.exists():
                try:
                    with open(compose_path, 'r') as f:
                        compose_data = yaml.safe_load(f)
                    
                    services = compose_data.get('services', {})
                    
                    for service_name, service_config in services.items():
                        # Check if internal service has exposed ports
                        if any(internal in service_name.lower() for internal in internal_services):
                            ports = service_config.get('ports', [])
                            if ports:
                                self.issues.append(SecurityIssue(
                                    id=f"EXPOSED_INTERNAL_{service_name}",
                                    type=SecurityIssueType.NETWORK_SECURITY,
                                    severity=SecuritySeverity.HIGH,
                                    file_path=str(compose_path.relative_to(self.project_root)),
                                    line_number=None,
                                    description=f"Internal service exposed externally: {service_name}",
                                    recommendation="Remove port mappings for internal services",
                                    ubuntu_specific=False,
                                    auto_fixable=True
                                ))
                                
                except Exception as e:
                    logger.error(f"Error checking exposed services in {compose_path}: {e}")  
  
    def _audit_authentication_mechanisms(self):
        """Audit authentication mechanisms for security issues."""
        logger.info("Auditing authentication mechanisms...")
        
        # Check JWT configuration
        self._check_jwt_security()
        
        # Check OAuth configuration
        self._check_oauth_security()
        
        # Check password handling
        self._check_password_security()
        
        # Check session management
        self._check_session_security()
    
    def _check_jwt_security(self):
        """Check JWT implementation for security issues."""
        # Look for JWT-related files
        jwt_files = []
        
        for root, dirs, files in os.walk(self.project_root):
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['node_modules', '__pycache__', 'venv']]
            
            for file in files:
                if file.endswith(('.py', '.js', '.ts')):
                    file_path = Path(root) / file
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                            
                        if 'jwt' in content.lower() or 'jsonwebtoken' in content.lower():
                            jwt_files.append(file_path)
                            
                            # Check for weak JWT secrets
                            lines = content.split('\n')
                            for i, line in enumerate(lines, 1):
                                if 'secret' in line.lower() and ('jwt' in line.lower() or 'token' in line.lower()):
                                    # Check for hardcoded secrets
                                    if any(weak in line.lower() for weak in ['secret', 'password', '123', 'test']):
                                        self.issues.append(SecurityIssue(
                                            id=f"JWT_WEAK_SECRET_{file}_{i}",
                                            type=SecurityIssueType.AUTHENTICATION,
                                            severity=SecuritySeverity.CRITICAL,
                                            file_path=str(file_path.relative_to(self.project_root)),
                                            line_number=i,
                                            description="Weak or hardcoded JWT secret detected",
                                            recommendation="Use strong, randomly generated secrets from environment variables",
                                            ubuntu_specific=False,
                                            auto_fixable=False
                                        ))
                                
                                # Check for missing expiration
                                if 'jwt.encode' in line and 'exp' not in line:
                                    self.issues.append(SecurityIssue(
                                        id=f"JWT_NO_EXPIRY_{file}_{i}",
                                        type=SecurityIssueType.AUTHENTICATION,
                                        severity=SecuritySeverity.HIGH,
                                        file_path=str(file_path.relative_to(self.project_root)),
                                        line_number=i,
                                        description="JWT token without expiration time",
                                        recommendation="Add expiration time to JWT tokens",
                                        ubuntu_specific=False,
                                        auto_fixable=False
                                    ))
                                    
                    except Exception:
                        continue
    
    def _check_oauth_security(self):
        """Check OAuth implementation for security issues."""
        oauth_patterns = [
            'oauth',
            'client_secret',
            'client_id',
            'redirect_uri',
            'authorization_code'
        ]
        
        for root, dirs, files in os.walk(self.project_root):
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['node_modules', '__pycache__', 'venv']]
            
            for file in files:
                if file.endswith(('.py', '.js', '.ts', '.json', '.yml', '.yaml')):
                    file_path = Path(root) / file
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                        
                        lines = content.split('\n')
                        for i, line in enumerate(lines, 1):
                            line_lower = line.lower()
                            
                            # Check for hardcoded OAuth secrets
                            if 'client_secret' in line_lower and '=' in line:
                                if not any(env_var in line for env_var in ['os.environ', 'process.env', '${', 'getenv']):
                                    self.issues.append(SecurityIssue(
                                        id=f"OAUTH_HARDCODED_SECRET_{file}_{i}",
                                        type=SecurityIssueType.AUTHENTICATION,
                                        severity=SecuritySeverity.CRITICAL,
                                        file_path=str(file_path.relative_to(self.project_root)),
                                        line_number=i,
                                        description="Hardcoded OAuth client secret",
                                        recommendation="Move OAuth secrets to environment variables",
                                        ubuntu_specific=False,
                                        auto_fixable=False
                                    ))
                            
                            # Check for insecure redirect URIs
                            if 'redirect_uri' in line_lower and 'http://' in line_lower:
                                self.issues.append(SecurityIssue(
                                    id=f"OAUTH_INSECURE_REDIRECT_{file}_{i}",
                                    type=SecurityIssueType.AUTHENTICATION,
                                    severity=SecuritySeverity.HIGH,
                                    file_path=str(file_path.relative_to(self.project_root)),
                                    line_number=i,
                                    description="Insecure HTTP redirect URI in OAuth configuration",
                                    recommendation="Use HTTPS for OAuth redirect URIs",
                                    ubuntu_specific=False,
                                    auto_fixable=True
                                ))
                                
                    except Exception:
                        continue
    
    def _check_password_security(self):
        """Check password handling for security issues."""
        password_patterns = [
            'password',
            'passwd',
            'pwd',
            'hash',
            'bcrypt',
            'scrypt',
            'pbkdf2'
        ]
        
        for root, dirs, files in os.walk(self.project_root):
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['node_modules', '__pycache__', 'venv']]
            
            for file in files:
                if file.endswith(('.py', '.js', '.ts')):
                    file_path = Path(root) / file
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                        
                        lines = content.split('\n')
                        for i, line in enumerate(lines, 1):
                            line_lower = line.lower()
                            
                            # Check for plaintext password storage
                            if 'password' in line_lower and '=' in line and 'hash' not in line_lower:
                                if any(indicator in line_lower for indicator in ['store', 'save', 'insert', 'update']):
                                    self.issues.append(SecurityIssue(
                                        id=f"PASSWORD_PLAINTEXT_{file}_{i}",
                                        type=SecurityIssueType.AUTHENTICATION,
                                        severity=SecuritySeverity.CRITICAL,
                                        file_path=str(file_path.relative_to(self.project_root)),
                                        line_number=i,
                                        description="Potential plaintext password storage",
                                        recommendation="Hash passwords before storage using bcrypt or similar",
                                        ubuntu_specific=False,
                                        auto_fixable=False
                                    ))
                            
                            # Check for weak hashing algorithms
                            weak_hashes = ['md5', 'sha1', 'sha256']  # SHA256 alone is not recommended for passwords
                            for weak_hash in weak_hashes:
                                if weak_hash in line_lower and 'password' in line_lower:
                                    self.issues.append(SecurityIssue(
                                        id=f"PASSWORD_WEAK_HASH_{file}_{i}",
                                        type=SecurityIssueType.AUTHENTICATION,
                                        severity=SecuritySeverity.HIGH,
                                        file_path=str(file_path.relative_to(self.project_root)),
                                        line_number=i,
                                        description=f"Weak password hashing algorithm: {weak_hash}",
                                        recommendation="Use bcrypt, scrypt, or Argon2 for password hashing",
                                        ubuntu_specific=False,
                                        auto_fixable=False
                                    ))
                                    
                    except Exception:
                        continue
    
    def _check_session_security(self):
        """Check session management for security issues."""
        session_files = []
        
        for root, dirs, files in os.walk(self.project_root):
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['node_modules', '__pycache__', 'venv']]
            
            for file in files:
                if file.endswith(('.py', '.js', '.ts')):
                    file_path = Path(root) / file
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                        
                        if 'session' in content.lower():
                            lines = content.split('\n')
                            for i, line in enumerate(lines, 1):
                                line_lower = line.lower()
                                
                                # Check for insecure session configuration
                                if 'session' in line_lower and 'secure' in line_lower and 'false' in line_lower:
                                    self.issues.append(SecurityIssue(
                                        id=f"SESSION_INSECURE_{file}_{i}",
                                        type=SecurityIssueType.AUTHENTICATION,
                                        severity=SecuritySeverity.MEDIUM,
                                        file_path=str(file_path.relative_to(self.project_root)),
                                        line_number=i,
                                        description="Session cookie not marked as secure",
                                        recommendation="Set secure flag for session cookies in production",
                                        ubuntu_specific=False,
                                        auto_fixable=True
                                    ))
                                
                                # Check for missing HttpOnly flag
                                if 'session' in line_lower and 'httponly' in line_lower and 'false' in line_lower:
                                    self.issues.append(SecurityIssue(
                                        id=f"SESSION_NO_HTTPONLY_{file}_{i}",
                                        type=SecurityIssueType.AUTHENTICATION,
                                        severity=SecuritySeverity.MEDIUM,
                                        file_path=str(file_path.relative_to(self.project_root)),
                                        line_number=i,
                                        description="Session cookie not marked as HttpOnly",
                                        recommendation="Set HttpOnly flag for session cookies",
                                        ubuntu_specific=False,
                                        auto_fixable=True
                                    ))
                                    
                    except Exception:
                        continue
    
    def _audit_authorization_controls(self):
        """Audit authorization controls for security issues."""
        logger.info("Auditing authorization controls...")
        
        # Check for role-based access control
        self._check_rbac_implementation()
        
        # Check for permission validation
        self._check_permission_validation()
        
        # Check for privilege escalation vulnerabilities
        self._check_privilege_escalation()
    
    def _check_rbac_implementation(self):
        """Check role-based access control implementation."""
        rbac_patterns = [
            'role',
            'permission',
            'authorize',
            'access_control',
            'rbac'
        ]
        
        for root, dirs, files in os.walk(self.project_root):
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['node_modules', '__pycache__', 'venv']]
            
            for file in files:
                if file.endswith(('.py', '.js', '.ts')):
                    file_path = Path(root) / file
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                        
                        lines = content.split('\n')
                        for i, line in enumerate(lines, 1):
                            line_lower = line.lower()
                            
                            # Check for hardcoded role checks
                            if 'role' in line_lower and ('==' in line or '!=' in line):
                                if any(role in line_lower for role in ['admin', 'user', 'guest']):
                                    self.issues.append(SecurityIssue(
                                        id=f"RBAC_HARDCODED_{file}_{i}",
                                        type=SecurityIssueType.AUTHORIZATION,
                                        severity=SecuritySeverity.MEDIUM,
                                        file_path=str(file_path.relative_to(self.project_root)),
                                        line_number=i,
                                        description="Hardcoded role check detected",
                                        recommendation="Use configurable role-based access control system",
                                        ubuntu_specific=False,
                                        auto_fixable=False
                                    ))
                            
                            # Check for missing authorization checks
                            if any(decorator in line for decorator in ['@app.route', '@router.', 'app.get', 'app.post']):
                                # Look for authorization decorator in next few lines
                                auth_found = False
                                for j in range(max(0, i-3), min(len(lines), i+3)):
                                    if any(auth in lines[j].lower() for auth in ['authorize', 'require', 'permission', 'auth']):
                                        auth_found = True
                                        break
                                
                                if not auth_found:
                                    self.issues.append(SecurityIssue(
                                        id=f"MISSING_AUTH_{file}_{i}",
                                        type=SecurityIssueType.AUTHORIZATION,
                                        severity=SecuritySeverity.HIGH,
                                        file_path=str(file_path.relative_to(self.project_root)),
                                        line_number=i,
                                        description="API endpoint without authorization check",
                                        recommendation="Add authorization decorator or middleware",
                                        ubuntu_specific=False,
                                        auto_fixable=False
                                    ))
                                    
                    except Exception:
                        continue
    
    def _check_permission_validation(self):
        """Check permission validation implementation."""
        # Look for SQL injection vulnerabilities
        sql_patterns = [
            r'SELECT.*\+.*',
            r'INSERT.*\+.*',
            r'UPDATE.*\+.*',
            r'DELETE.*\+.*',
            r'\.format\(',
            r'%.*%'
        ]
        
        for root, dirs, files in os.walk(self.project_root):
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['node_modules', '__pycache__', 'venv']]
            
            for file in files:
                if file.endswith(('.py', '.js', '.ts')):
                    file_path = Path(root) / file
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                        
                        lines = content.split('\n')
                        for i, line in enumerate(lines, 1):
                            # Check for potential SQL injection
                            for pattern in sql_patterns:
                                if re.search(pattern, line, re.IGNORECASE):
                                    if any(sql_keyword in line.upper() for sql_keyword in ['SELECT', 'INSERT', 'UPDATE', 'DELETE']):
                                        self.issues.append(SecurityIssue(
                                            id=f"SQL_INJECTION_{file}_{i}",
                                            type=SecurityIssueType.AUTHORIZATION,
                                            severity=SecuritySeverity.CRITICAL,
                                            file_path=str(file_path.relative_to(self.project_root)),
                                            line_number=i,
                                            description="Potential SQL injection vulnerability",
                                            recommendation="Use parameterized queries or ORM methods",
                                            ubuntu_specific=False,
                                            auto_fixable=False
                                        ))
                                        break
                            
                            # Check for path traversal vulnerabilities
                            if '../' in line or '..\\' in line:
                                if any(func in line for func in ['open(', 'read(', 'write(', 'file(']):
                                    self.issues.append(SecurityIssue(
                                        id=f"PATH_TRAVERSAL_{file}_{i}",
                                        type=SecurityIssueType.AUTHORIZATION,
                                        severity=SecuritySeverity.HIGH,
                                        file_path=str(file_path.relative_to(self.project_root)),
                                        line_number=i,
                                        description="Potential path traversal vulnerability",
                                        recommendation="Validate and sanitize file paths",
                                        ubuntu_specific=False,
                                        auto_fixable=False
                                    ))
                                    
                    except Exception:
                        continue
    
    def _check_privilege_escalation(self):
        """Check for privilege escalation vulnerabilities."""
        dangerous_functions = [
            'eval(',
            'exec(',
            'subprocess.call',
            'os.system',
            'shell_exec',
            'system(',
            'popen('
        ]
        
        for root, dirs, files in os.walk(self.project_root):
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['node_modules', '__pycache__', 'venv']]
            
            for file in files:
                if file.endswith(('.py', '.js', '.ts')):
                    file_path = Path(root) / file
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                        
                        lines = content.split('\n')
                        for i, line in enumerate(lines, 1):
                            for dangerous_func in dangerous_functions:
                                if dangerous_func in line:
                                    self.issues.append(SecurityIssue(
                                        id=f"DANGEROUS_FUNC_{file}_{i}",
                                        type=SecurityIssueType.AUTHORIZATION,
                                        severity=SecuritySeverity.HIGH,
                                        file_path=str(file_path.relative_to(self.project_root)),
                                        line_number=i,
                                        description=f"Dangerous function usage: {dangerous_func}",
                                        recommendation="Avoid dynamic code execution, use safer alternatives",
                                        ubuntu_specific=False,
                                        auto_fixable=False
                                    ))
                                    
                    except Exception:
                        continue
    
    def _analyze_security_configurations(self):
        """Analyze security configurations."""
        logger.info("Analyzing security configurations...")
        
        # Check environment files
        self._check_environment_security()
        
        # Check configuration files
        self._check_config_security()
        
        # Check Docker security
        self._check_docker_security()
    
    def _check_environment_security(self):
        """Check environment file security."""
        env_files = ['.env', '.env.production', '.env.example', 'backend/.env.example']
        
        for env_file in env_files:
            env_path = self.project_root / env_file
            if env_path.exists():
                try:
                    with open(env_path, 'r') as f:
                        lines = f.readlines()
                    
                    for i, line in enumerate(lines, 1):
                        line = line.strip()
                        if '=' in line and not line.startswith('#'):
                            key, value = line.split('=', 1)
                            
                            # Check for weak secrets
                            if any(secret_key in key.lower() for secret_key in ['secret', 'key', 'password', 'token']):
                                if len(value) < 32:
                                    self.issues.append(SecurityIssue(
                                        id=f"WEAK_SECRET_{env_file}_{i}",
                                        type=SecurityIssueType.CONFIGURATION,
                                        severity=SecuritySeverity.HIGH,
                                        file_path=env_file,
                                        line_number=i,
                                        description=f"Weak secret value: {key}",
                                        recommendation="Use strong, randomly generated secrets (32+ characters)",
                                        ubuntu_specific=False,
                                        auto_fixable=False
                                    ))
                            
                            # Check for default values
                            default_values = ['changeme', 'password', 'secret', 'admin', '123456']
                            if value.lower() in default_values:
                                self.issues.append(SecurityIssue(
                                    id=f"DEFAULT_VALUE_{env_file}_{i}",
                                    type=SecurityIssueType.CONFIGURATION,
                                    severity=SecuritySeverity.CRITICAL,
                                    file_path=env_file,
                                    line_number=i,
                                    description=f"Default/weak value for {key}",
                                    recommendation="Change default values to secure alternatives",
                                    ubuntu_specific=False,
                                    auto_fixable=False
                                ))
                                
                except Exception as e:
                    logger.error(f"Error checking environment file {env_path}: {e}")
    
    def _check_config_security(self):
        """Check configuration file security."""
        config_files = [
            'config/zotero_config.production.json',
            'config/deployment-config.yml',
            'backend/config'
        ]
        
        for config_path in config_files:
            full_path = self.project_root / config_path
            if full_path.exists():
                if full_path.is_file():
                    self._analyze_config_file(full_path)
                elif full_path.is_dir():
                    for config_file in full_path.rglob('*'):
                        if config_file.is_file() and config_file.suffix in ['.json', '.yml', '.yaml', '.py']:
                            self._analyze_config_file(config_file)
    
    def _analyze_config_file(self, config_path: Path):
        """Analyze a specific configuration file."""
        try:
            with open(config_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            lines = content.split('\n')
            for i, line in enumerate(lines, 1):
                line_lower = line.lower()
                
                # Check for hardcoded credentials
                if any(cred in line_lower for cred in ['password', 'secret', 'key', 'token']):
                    if '=' in line or ':' in line:
                        # Extract value
                        if '=' in line:
                            value = line.split('=', 1)[1].strip()
                        else:
                            value = line.split(':', 1)[1].strip()
                        
                        # Remove quotes and common formatting
                        value = value.strip('\'"').strip(',').strip()
                        
                        if value and not any(env_var in value for env_var in ['${', 'os.environ', 'process.env']):
                            self.issues.append(SecurityIssue(
                                id=f"HARDCODED_CRED_{config_path.name}_{i}",
                                type=SecurityIssueType.CONFIGURATION,
                                severity=SecuritySeverity.HIGH,
                                file_path=str(config_path.relative_to(self.project_root)),
                                line_number=i,
                                description="Hardcoded credential in configuration",
                                recommendation="Move credentials to environment variables",
                                ubuntu_specific=False,
                                auto_fixable=False
                            ))
                
                # Check for debug mode in production
                if 'debug' in line_lower and 'true' in line_lower:
                    if 'prod' in str(config_path).lower():
                        self.issues.append(SecurityIssue(
                            id=f"DEBUG_PROD_{config_path.name}_{i}",
                            type=SecurityIssueType.CONFIGURATION,
                            severity=SecuritySeverity.MEDIUM,
                            file_path=str(config_path.relative_to(self.project_root)),
                            line_number=i,
                            description="Debug mode enabled in production configuration",
                            recommendation="Disable debug mode in production",
                            ubuntu_specific=False,
                            auto_fixable=True
                        ))
                        
        except Exception as e:
            logger.error(f"Error analyzing config file {config_path}: {e}")
    
    def _check_docker_security(self):
        """Check Docker security configurations."""
        dockerfile_paths = [
            'Dockerfile.backend',
            'Dockerfile.frontend',
            'Dockerfile.nginx',
            'backend/Dockerfile'
        ]
        
        for dockerfile in dockerfile_paths:
            dockerfile_path = self.project_root / dockerfile
            if dockerfile_path.exists():
                self._analyze_dockerfile_security(dockerfile_path)
    
    def _analyze_dockerfile_security(self, dockerfile_path: Path):
        """Analyze Dockerfile for security issues."""
        try:
            with open(dockerfile_path, 'r') as f:
                lines = f.readlines()
            
            for i, line in enumerate(lines, 1):
                line = line.strip()
                
                # Check for running as root
                if line.startswith('USER') and 'root' in line:
                    self.issues.append(SecurityIssue(
                        id=f"DOCKER_ROOT_{dockerfile_path.name}_{i}",
                        type=SecurityIssueType.CONFIGURATION,
                        severity=SecuritySeverity.HIGH,
                        file_path=str(dockerfile_path.relative_to(self.project_root)),
                        line_number=i,
                        description="Container running as root user",
                        recommendation="Create and use non-root user",
                        ubuntu_specific=True,
                        auto_fixable=True
                    ))
                
                # Check for ADD instead of COPY
                if line.startswith('ADD ') and not line.startswith('ADD --'):
                    self.issues.append(SecurityIssue(
                        id=f"DOCKER_ADD_{dockerfile_path.name}_{i}",
                        type=SecurityIssueType.CONFIGURATION,
                        severity=SecuritySeverity.LOW,
                        file_path=str(dockerfile_path.relative_to(self.project_root)),
                        line_number=i,
                        description="Using ADD instead of COPY",
                        recommendation="Use COPY instead of ADD for better security",
                        ubuntu_specific=False,
                        auto_fixable=True
                    ))
                
                # Check for latest tag
                if 'FROM' in line and ':latest' in line:
                    self.issues.append(SecurityIssue(
                        id=f"DOCKER_LATEST_{dockerfile_path.name}_{i}",
                        type=SecurityIssueType.CONFIGURATION,
                        severity=SecuritySeverity.MEDIUM,
                        file_path=str(dockerfile_path.relative_to(self.project_root)),
                        line_number=i,
                        description="Using 'latest' tag in base image",
                        recommendation="Pin to specific version tags",
                        ubuntu_specific=False,
                        auto_fixable=True
                    ))
                    
        except Exception as e:
            logger.error(f"Error analyzing Dockerfile {dockerfile_path}: {e}")
    
    def _check_secrets_exposure(self):
        """Check for exposed secrets in code."""
        logger.info("Checking for exposed secrets...")
        
        # Common secret patterns
        secret_patterns = [
            (r'[A-Za-z0-9]{20,}', 'Potential API key or token'),
            (r'sk-[A-Za-z0-9]{48}', 'OpenAI API key'),
            (r'xoxb-[A-Za-z0-9-]{50,}', 'Slack bot token'),
            (r'ghp_[A-Za-z0-9]{36}', 'GitHub personal access token'),
            (r'AIza[A-Za-z0-9_-]{35}', 'Google API key'),
            (r'AKIA[A-Z0-9]{16}', 'AWS access key'),
            (r'[0-9a-f]{32}', 'MD5 hash (potential secret)'),
            (r'[0-9a-f]{40}', 'SHA1 hash (potential secret)'),
            (r'[0-9a-f]{64}', 'SHA256 hash (potential secret)')
        ]
        
        for root, dirs, files in os.walk(self.project_root):
            # Skip hidden directories and common ignore patterns
            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['node_modules', '__pycache__', 'venv']]
            
            for file in files:
                if file.endswith(('.py', '.js', '.ts', '.json', '.yml', '.yaml', '.env')):
                    file_path = Path(root) / file
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                        
                        lines = content.split('\n')
                        for i, line in enumerate(lines, 1):
                            for pattern, description in secret_patterns:
                                matches = re.findall(pattern, line)
                                for match in matches:
                                    # Skip common false positives
                                    if self._is_likely_secret(match, line):
                                        self.issues.append(SecurityIssue(
                                            id=f"SECRET_EXPOSE_{file}_{i}_{match[:8]}",
                                            type=SecurityIssueType.SECRETS_EXPOSURE,
                                            severity=SecuritySeverity.HIGH,
                                            file_path=str(file_path.relative_to(self.project_root)),
                                            line_number=i,
                                            description=f"{description}: {match[:10]}...",
                                            recommendation="Move secrets to environment variables or secure vault",
                                            ubuntu_specific=False,
                                            auto_fixable=False
                                        ))
                                        
                    except Exception:
                        continue
    
    def _is_likely_secret(self, match: str, line: str) -> bool:
        """Determine if a match is likely a real secret."""
        # Skip common false positives
        false_positives = [
            'example',
            'test',
            'demo',
            'placeholder',
            'changeme',
            'your_key_here',
            'insert_key_here',
            '0' * len(match),  # All zeros
            '1' * len(match),  # All ones
        ]
        
        match_lower = match.lower()
        line_lower = line.lower()
        
        # Skip if it's clearly a placeholder
        if any(fp in match_lower for fp in false_positives):
            return False
        
        # Skip if it's in a comment
        if line.strip().startswith('#') or line.strip().startswith('//'):
            return False
        
        # Skip if it's clearly a hash of something common
        if any(word in line_lower for word in ['hash', 'checksum', 'digest']):
            return False
        
        # More likely to be a secret if it's assigned to a variable with secret-like name
        secret_var_names = ['key', 'secret', 'token', 'password', 'api']
        if any(var_name in line_lower for var_name in secret_var_names):
            return True
        
        # Check if it looks like a real secret (has good entropy)
        if len(set(match)) > len(match) * 0.6:  # Good character diversity
            return True
        
        return False
    
    def _is_gitignored(self, file_path: Path) -> bool:
        """Check if a file is in .gitignore."""
        gitignore_path = self.project_root / '.gitignore'
        if not gitignore_path.exists():
            return False
        
        try:
            with open(gitignore_path, 'r') as f:
                gitignore_content = f.read()
            
            relative_path = str(file_path.relative_to(self.project_root))
            
            # Simple gitignore check (not comprehensive)
            for line in gitignore_content.split('\n'):
                line = line.strip()
                if line and not line.startswith('#'):
                    if line in relative_path or relative_path.endswith(line):
                        return True
            
            return False
            
        except Exception:
            return False
    
    def _get_known_vulnerable_npm_packages(self) -> List[str]:
        """Get list of known vulnerable npm packages."""
        # This would ideally be updated from a vulnerability database
        return [
            'event-stream',
            'flatmap-stream',
            'eslint-scope',
            'getcookies',
            'rc',
            'lodash',  # Older versions
            'handlebars',  # Older versions
            'jquery',  # Older versions
            'bootstrap'  # Older versions
        ]
    
    def _map_safety_severity(self, severity: str) -> SecuritySeverity:
        """Map safety severity to our severity enum."""
        severity_map = {
            'critical': SecuritySeverity.CRITICAL,
            'high': SecuritySeverity.HIGH,
            'medium': SecuritySeverity.MEDIUM,
            'low': SecuritySeverity.LOW
        }
        return severity_map.get(severity.lower(), SecuritySeverity.MEDIUM)
    
    def _map_npm_severity(self, severity: str) -> SecuritySeverity:
        """Map npm audit severity to our severity enum."""
        severity_map = {
            'critical': SecuritySeverity.CRITICAL,
            'high': SecuritySeverity.HIGH,
            'moderate': SecuritySeverity.MEDIUM,
            'low': SecuritySeverity.LOW,
            'info': SecuritySeverity.INFO
        }
        return severity_map.get(severity.lower(), SecuritySeverity.MEDIUM)
    
    def _map_cvss_to_severity(self, versions: List[str]) -> SecuritySeverity:
        """Map CVSS score to severity (simplified)."""
        # This is a simplified mapping - in practice you'd parse actual CVSS scores
        if not versions:
            return SecuritySeverity.MEDIUM
        return SecuritySeverity.HIGH  # Conservative approach
    
    def _generate_summary_stats(self):
        """Generate summary statistics."""
        self.scan_results['total_issues'] = len(self.issues)
        
        for issue in self.issues:
            if issue.severity == SecuritySeverity.CRITICAL:
                self.scan_results['critical_issues'] += 1
            elif issue.severity == SecuritySeverity.HIGH:
                self.scan_results['high_issues'] += 1
            elif issue.severity == SecuritySeverity.MEDIUM:
                self.scan_results['medium_issues'] += 1
            elif issue.severity == SecuritySeverity.LOW:
                self.scan_results['low_issues'] += 1
            
            if issue.ubuntu_specific:
                self.scan_results['ubuntu_specific_issues'] += 1
            
            if issue.auto_fixable:
                self.scan_results['auto_fixable_issues'] += 1
    
    def _format_results(self) -> Dict[str, Any]:
        """Format scan results for output."""
        return {
            'summary': self.scan_results,
            'issues': [issue.to_dict() for issue in self.issues],
            'recommendations': self._generate_recommendations()
        }
    
    def _generate_recommendations(self) -> List[str]:
        """Generate high-level recommendations based on findings."""
        recommendations = []
        
        critical_count = self.scan_results['critical_issues']
        high_count = self.scan_results['high_issues']
        ubuntu_count = self.scan_results['ubuntu_specific_issues']
        
        if critical_count > 0:
            recommendations.append(f"Address {critical_count} critical security issues immediately")
        
        if high_count > 0:
            recommendations.append(f"Review and fix {high_count} high-severity security issues")
        
        if ubuntu_count > 0:
            recommendations.append(f"Review {ubuntu_count} Ubuntu-specific compatibility issues")
        
        if self.scan_results['auto_fixable_issues'] > 0:
            recommendations.append(f"{self.scan_results['auto_fixable_issues']} issues can be auto-fixed")
        
        # Add general recommendations
        recommendations.extend([
            "Implement automated security scanning in CI/CD pipeline",
            "Regular dependency updates and vulnerability monitoring",
            "Use environment variables for all sensitive configuration",
            "Implement proper file permissions for Ubuntu deployment",
            "Enable security headers in web server configuration"
        ])
        
        return recommendations

def main():
    """Main function to run security vulnerability scanner."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Security Vulnerability Scanner')
    parser.add_argument('--project-root', default='.', help='Project root directory')
    parser.add_argument('--output', help='Output file for results (JSON format)')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose logging')
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    scanner = SecurityVulnerabilityScanner(args.project_root)
    results = scanner.run_comprehensive_scan()
    
    # Output results
    if args.output:
        with open(args.output, 'w') as f:
            json.dump(results, f, indent=2)
        print(f"Results written to {args.output}")
    else:
        print(json.dumps(results, indent=2))
    
    # Print summary
    summary = results['summary']
    print(f"\n=== Security Scan Summary ===")
    print(f"Total Issues: {summary['total_issues']}")
    print(f"Critical: {summary['critical_issues']}")
    print(f"High: {summary['high_issues']}")
    print(f"Medium: {summary['medium_issues']}")
    print(f"Low: {summary['low_issues']}")
    print(f"Ubuntu-specific: {summary['ubuntu_specific_issues']}")
    print(f"Auto-fixable: {summary['auto_fixable_issues']}")
    
    return 0 if summary['critical_issues'] == 0 else 1

if __name__ == '__main__':
    sys.exit(main())