"""
Unit tests for Zotero authentication service
"""
import pytest
import asyncio
from datetime import datetime, timedelta
from unittest.mock import Mock, AsyncMock, patch, MagicMock
from aiohttp import ClientError, ClientTimeout
import aiohttp

from services.zotero.zotero_auth_service import ZoteroAuthService, ZoteroAuthError
from models.zotero_models import ZoteroConnection


class TestZoteroAuthService:
    """Test cases for ZoteroAuthService"""
    
    @pytest.fixture
    def auth_service(self):
        """Create ZoteroAuthService instance for testing"""
        return ZoteroAuthService()
    
    @pytest.fixture
    def mock_db_session(self):
        """Mock database session"""
        with patch('services.zotero.zotero_auth_service.SessionLocal') as mock_session:
            mock_db = Mock()
            mock_session.return_value = mock_db
            yield mock_db
    
    def test_generate_oauth_state(self, auth_service):
        """Test OAuth state generation"""
        user_id = "test_user_123"
        state, code_challenge = auth_service.generate_oauth_state(user_id)
        
        # Verify state is generated
        assert state is not None
        assert len(state) > 20  # Should be a long random string
        
        # Verify PKCE challenge is generated by default
        assert code_challenge is not None
        assert len(code_challenge) > 20
        
        # Verify state is stored
        assert state in auth_service._oauth_states
        state_data = auth_service._oauth_states[state]
        assert state_data["user_id"] == user_id
        assert not state_data["used"]
        assert state_data["expires_at"] > datetime.now()
        assert state_data["use_pkce"] is True
        
        # Verify PKCE verifier is stored
        assert state in auth_service._pkce_verifiers
    
    def test_generate_oauth_state_without_pkce(self, auth_service):
        """Test OAuth state generation without PKCE"""
        user_id = "test_user_123"
        state, code_challenge = auth_service.generate_oauth_state(user_id, use_pkce=False)
        
        # Verify state is generated
        assert state is not None
        assert len(state) > 20
        
        # Verify no PKCE challenge is generated
        assert code_challenge is None
        
        # Verify state data
        state_data = auth_service._oauth_states[state]
        assert state_data["use_pkce"] is False
        
        # Verify no PKCE verifier is stored
        assert state not in auth_service._pkce_verifiers
    
    def test_validate_oauth_state_valid(self, auth_service):
        """Test OAuth state validation with valid state"""
        user_id = "test_user_123"
        state, _ = auth_service.generate_oauth_state(user_id)
        
        # Should validate successfully
        assert auth_service.validate_oauth_state(state, user_id) is True
        
        # State should be marked as used
        assert auth_service._oauth_states[state]["used"] is True
        assert "validated_at" in auth_service._oauth_states[state]
    
    def test_validate_oauth_state_invalid(self, auth_service):
        """Test OAuth state validation with invalid state"""
        # Non-existent state
        assert auth_service.validate_oauth_state("invalid_state", "user_123") is False
        
        # Wrong user ID
        user_id = "test_user_123"
        state, _ = auth_service.generate_oauth_state(user_id)
        assert auth_service.validate_oauth_state(state, "wrong_user") is False
    
    def test_validate_oauth_state_expired(self, auth_service):
        """Test OAuth state validation with expired state"""
        user_id = "test_user_123"
        state, _ = auth_service.generate_oauth_state(user_id)
        
        # Manually expire the state
        auth_service._oauth_states[state]["expires_at"] = datetime.now() - timedelta(minutes=1)
        
        # Should fail validation
        assert auth_service.validate_oauth_state(state, user_id) is False
        
        # State should be removed
        assert state not in auth_service._oauth_states
        # PKCE verifier should also be removed
        assert state not in auth_service._pkce_verifiers
    
    def test_validate_oauth_state_already_used(self, auth_service):
        """Test OAuth state validation with already used state"""
        user_id = "test_user_123"
        state, _ = auth_service.generate_oauth_state(user_id)
        
        # Use the state once
        assert auth_service.validate_oauth_state(state, user_id) is True
        
        # Should fail on second use
        assert auth_service.validate_oauth_state(state, user_id) is False
    
    def test_get_authorization_url(self, auth_service):
        """Test authorization URL generation"""
        user_id = "test_user_123"
        scopes = ["all"]
        
        auth_url, state = auth_service.get_authorization_url(user_id, scopes)
        
        # Verify URL structure
        assert auth_url.startswith(auth_service.oauth_base_url)
        assert "response_type=code" in auth_url
        assert f"client_id={auth_service.client_id}" in auth_url
        assert f"redirect_uri={auth_service.redirect_uri}" in auth_url
        assert f"state={state}" in auth_url
        assert "scope=all" in auth_url
        
        # Verify PKCE parameters are included by default
        assert "code_challenge=" in auth_url
        assert "code_challenge_method=S256" in auth_url
        
        # Verify state is stored
        assert state in auth_service._oauth_states
        assert state in auth_service._pkce_verifiers
    
    def test_get_authorization_url_without_pkce(self, auth_service):
        """Test authorization URL generation without PKCE"""
        user_id = "test_user_123"
        scopes = ["all"]
        
        auth_url, state = auth_service.get_authorization_url(user_id, scopes, use_pkce=False)
        
        # Verify URL structure
        assert auth_url.startswith(auth_service.oauth_base_url)
        assert "response_type=code" in auth_url
        
        # Verify PKCE parameters are NOT included
        assert "code_challenge=" not in auth_url
        assert "code_challenge_method=" not in auth_url
        
        # Verify state is stored but no PKCE verifier
        assert state in auth_service._oauth_states
        assert state not in auth_service._pkce_verifiers
    
    @pytest.mark.asyncio
    async def test_exchange_code_for_token_success(self, auth_service):
        """Test successful token exchange"""
        user_id = "test_user_123"
        auth_code = "test_auth_code"
        state, _ = auth_service.generate_oauth_state(user_id)
        
        # Mock successful HTTP response
        mock_response_text = "access_token=test_token&userID=12345&username=testuser"
        
        with patch('aiohttp.ClientSession') as mock_session:
            mock_response = AsyncMock()
            mock_response.status = 200
            mock_response.text = AsyncMock(return_value=mock_response_text)
            
            mock_session.return_value.__aenter__.return_value.post.return_value.__aenter__.return_value = mock_response
            
            result = await auth_service.exchange_code_for_token(auth_code, state, user_id)
            
            # Verify result
            assert result["access_token"] == "test_token"
            assert result["zotero_user_id"] == "12345"
            assert result["username"] == "testuser"
            assert result["token_type"] == "Bearer"
            assert "obtained_at" in result
            assert "pkce_used" in result
            
            # Verify PKCE verifier was cleaned up
            assert state not in auth_service._pkce_verifiers
    
    @pytest.mark.asyncio
    async def test_exchange_code_for_token_invalid_state(self, auth_service):
        """Test token exchange with invalid state"""
        user_id = "test_user_123"
        auth_code = "test_auth_code"
        invalid_state = "invalid_state"
        
        with pytest.raises(ZoteroAuthError) as exc_info:
            await auth_service.exchange_code_for_token(auth_code, invalid_state, user_id)
        
        assert exc_info.value.error_code == "INVALID_STATE"
    
    @pytest.mark.asyncio
    async def test_exchange_code_for_token_http_error(self, auth_service):
        """Test token exchange with HTTP error"""
        user_id = "test_user_123"
        auth_code = "test_auth_code"
        state = auth_service.generate_oauth_state(user_id)
        
        with patch('aiohttp.ClientSession') as mock_session:
            mock_response = AsyncMock()
            mock_response.status = 400
            mock_response.text = AsyncMock(return_value="error=invalid_request")
            
            mock_session.return_value.__aenter__.return_value.post.return_value.__aenter__.return_value = mock_response
            
            with pytest.raises(ZoteroAuthError) as exc_info:
                await auth_service.exchange_code_for_token(auth_code, state, user_id)
            
            assert exc_info.value.error_code == "TOKEN_EXCHANGE_FAILED"
    
    @pytest.mark.asyncio
    async def test_exchange_code_for_token_invalid_response(self, auth_service):
        """Test token exchange with invalid response"""
        user_id = "test_user_123"
        auth_code = "test_auth_code"
        state = auth_service.generate_oauth_state(user_id)
        
        # Mock response missing required fields
        mock_response_text = "some_other_field=value"
        
        with patch('aiohttp.ClientSession') as mock_session:
            mock_response = AsyncMock()
            mock_response.status = 200
            mock_response.text = AsyncMock(return_value=mock_response_text)
            
            mock_session.return_value.__aenter__.return_value.post.return_value.__aenter__.return_value = mock_response
            
            with pytest.raises(ZoteroAuthError) as exc_info:
                await auth_service.exchange_code_for_token(auth_code, state, user_id)
            
            assert exc_info.value.error_code == "INVALID_TOKEN_RESPONSE"
    
    @pytest.mark.asyncio
    async def test_exchange_code_for_token_network_error(self, auth_service):
        """Test token exchange with network error"""
        user_id = "test_user_123"
        auth_code = "test_auth_code"
        state = auth_service.generate_oauth_state(user_id)
        
        with patch('aiohttp.ClientSession') as mock_session:
            mock_session.return_value.__aenter__.return_value.post.side_effect = ClientError("Network error")
            
            with pytest.raises(ZoteroAuthError) as exc_info:
                await auth_service.exchange_code_for_token(auth_code, state, user_id)
            
            assert exc_info.value.error_code == "HTTP_ERROR"
    
    @pytest.mark.asyncio
    async def test_store_connection_new(self, auth_service, mock_db_session):
        """Test storing new connection"""
        user_id = "test_user_123"
        token_data = {
            "access_token": "test_token",
            "zotero_user_id": "12345",
            "username": "testuser",
            "token_type": "Bearer",
            "obtained_at": datetime.now().isoformat()
        }
        
        # Mock no existing connection
        mock_db_session.query.return_value.filter.return_value.first.return_value = None
        
        result = await auth_service.store_connection(user_id, token_data)
        
        # Verify connection was added
        mock_db_session.add.assert_called_once()
        mock_db_session.commit.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_store_connection_update_existing(self, auth_service, mock_db_session):
        """Test updating existing connection"""
        user_id = "test_user_123"
        token_data = {
            "access_token": "new_token",
            "zotero_user_id": "12345",
            "username": "testuser",
            "token_type": "Bearer",
            "obtained_at": datetime.now().isoformat()
        }
        
        # Mock existing connection
        existing_connection = Mock(spec=ZoteroConnection)
        existing_connection.connection_metadata = {}
        mock_db_session.query.return_value.filter.return_value.first.return_value = existing_connection
        
        result = await auth_service.store_connection(user_id, token_data)
        
        # Verify connection was updated
        assert existing_connection.access_token == "new_token"
        assert existing_connection.connection_status == "active"
        mock_db_session.commit.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_store_connection_database_error(self, auth_service, mock_db_session):
        """Test storing connection with database error"""
        user_id = "test_user_123"
        token_data = {
            "access_token": "test_token",
            "zotero_user_id": "12345",
            "username": "testuser"
        }
        
        # Mock database error
        mock_db_session.query.side_effect = Exception("Database error")
        
        with pytest.raises(ZoteroAuthError) as exc_info:
            await auth_service.store_connection(user_id, token_data)
        
        assert exc_info.value.error_code == "STORAGE_ERROR"
        mock_db_session.rollback.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_create_api_key_connection_success(self, auth_service, mock_db_session):
        """Test creating API key connection"""
        user_id = "test_user_123"
        api_key = "test_api_key"
        zotero_user_id = "12345"
        
        # Mock successful API key validation
        with patch('services.zotero.zotero_auth_service.ZoteroAPIClient') as mock_client:
            mock_client.return_value.__aenter__.return_value.test_connection = AsyncMock(return_value={"is_valid": True})
            
            # Mock no existing connection
            mock_db_session.query.return_value.filter.return_value.first.return_value = None
            
            result = await auth_service.create_api_key_connection(user_id, api_key, zotero_user_id)
            
            # Verify connection was added
            mock_db_session.add.assert_called_once()
            mock_db_session.commit.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_create_api_key_connection_invalid_key(self, auth_service):
        """Test creating API key connection with invalid key"""
        user_id = "test_user_123"
        api_key = "invalid_key"
        zotero_user_id = "12345"
        
        # Mock failed API key validation
        with patch('services.zotero.zotero_auth_service.ZoteroAPIClient') as mock_client:
            mock_client.return_value.__aenter__.return_value.test_connection = AsyncMock(return_value={"is_valid": False})
            
            with pytest.raises(ZoteroAuthError):
                await auth_service.create_api_key_connection(user_id, api_key, zotero_user_id)
    
    @pytest.mark.asyncio
    async def test_get_user_connections(self, auth_service, mock_db_session):
        """Test getting user connections"""
        user_id = "test_user_123"
        
        # Mock connections
        mock_connections = [Mock(spec=ZoteroConnection), Mock(spec=ZoteroConnection)]
        mock_db_session.query.return_value.filter.return_value.all.return_value = mock_connections
        
        result = await auth_service.get_user_connections(user_id)
        
        assert result == mock_connections
        mock_db_session.query.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_get_active_connection(self, auth_service, mock_db_session):
        """Test getting active connection"""
        user_id = "test_user_123"
        
        # Mock active connection
        mock_connection = Mock(spec=ZoteroConnection)
        mock_db_session.query.return_value.filter.return_value.first.return_value = mock_connection
        
        result = await auth_service.get_active_connection(user_id)
        
        assert result == mock_connection
    
    @pytest.mark.asyncio
    async def test_revoke_connection_success(self, auth_service, mock_db_session):
        """Test revoking connection"""
        user_id = "test_user_123"
        connection_id = "conn_123"
        
        # Mock connection
        mock_connection = Mock(spec=ZoteroConnection)
        mock_db_session.query.return_value.filter.return_value.first.return_value = mock_connection
        
        result = await auth_service.revoke_connection(user_id, connection_id)
        
        assert result is True
        assert mock_connection.connection_status == "revoked"
        assert mock_connection.sync_enabled is False
        mock_db_session.commit.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_revoke_connection_not_found(self, auth_service, mock_db_session):
        """Test revoking non-existent connection"""
        user_id = "test_user_123"
        connection_id = "nonexistent_conn"
        
        # Mock no connection found
        mock_db_session.query.return_value.filter.return_value.first.return_value = None
        
        result = await auth_service.revoke_connection(user_id, connection_id)
        
        assert result is False
    
    @pytest.mark.asyncio
    async def test_validate_connection_success(self, auth_service):
        """Test validating connection"""
        mock_connection = Mock(spec=ZoteroConnection)
        mock_connection.access_token = "test_token"
        mock_connection.zotero_user_id = "12345"
        
        with patch('services.zotero.zotero_auth_service.ZoteroAPIClient') as mock_client:
            mock_client.return_value.__aenter__.return_value.test_connection = AsyncMock(return_value={"is_valid": True})
            
            result = await auth_service.validate_connection(mock_connection)
            
            assert result is True
    
    @pytest.mark.asyncio
    async def test_validate_connection_failure(self, auth_service, mock_db_session):
        """Test validating invalid connection"""
        mock_connection = Mock(spec=ZoteroConnection)
        mock_connection.access_token = "invalid_token"
        mock_connection.zotero_user_id = "12345"
        
        with patch('services.zotero.zotero_auth_service.ZoteroAPIClient') as mock_client:
            mock_client.return_value.__aenter__.return_value.test_connection = AsyncMock(return_value={"is_valid": False})
            
            with patch('services.zotero.zotero_auth_service.SessionLocal') as mock_session:
                mock_db = Mock()
                mock_session.return_value = mock_db
                
                result = await auth_service.validate_connection(mock_connection)
                
                assert result is False
                assert mock_connection.connection_status == "error"
    
    @pytest.mark.asyncio
    async def test_refresh_token_success(self, auth_service, mock_db_session):
        """Test token refresh (validation)"""
        mock_connection = Mock(spec=ZoteroConnection)
        mock_connection.id = "conn_123"
        mock_connection.connection_metadata = {}
        
        # Mock successful validation
        auth_service.validate_connection = AsyncMock(return_value=True)
        
        result = await auth_service.refresh_token(mock_connection)
        
        assert result is True
        mock_db_session.commit.assert_called_once()
    
    @pytest.mark.asyncio
    async def test_get_connection_with_valid_token_recent_validation(self, auth_service):
        """Test getting connection with recently validated token"""
        user_id = "test_user_123"
        
        mock_connection = Mock(spec=ZoteroConnection)
        mock_connection.connection_metadata = {
            "last_validated": (datetime.now() - timedelta(minutes=30)).isoformat()
        }
        
        auth_service.get_active_connection = AsyncMock(return_value=mock_connection)
        
        result = await auth_service.get_connection_with_valid_token(user_id)
        
        assert result == mock_connection
    
    @pytest.mark.asyncio
    async def test_get_connection_with_valid_token_needs_validation(self, auth_service):
        """Test getting connection that needs validation"""
        user_id = "test_user_123"
        
        mock_connection = Mock(spec=ZoteroConnection)
        mock_connection.connection_metadata = {
            "last_validated": (datetime.now() - timedelta(hours=2)).isoformat()
        }
        
        auth_service.get_active_connection = AsyncMock(return_value=mock_connection)
        auth_service.refresh_token = AsyncMock(return_value=True)
        
        result = await auth_service.get_connection_with_valid_token(user_id)
        
        assert result == mock_connection
        auth_service.refresh_token.assert_called_once_with(mock_connection)
    
    def test_cleanup_expired_states(self, auth_service):
        """Test cleanup of expired OAuth states"""
        user_id = "test_user_123"
        
        # Create some states
        valid_state = auth_service.generate_oauth_state(user_id)
        expired_state = auth_service.generate_oauth_state(user_id)
        
        # Manually expire one state
        auth_service._oauth_states[expired_state]["expires_at"] = datetime.now() - timedelta(minutes=1)
        
        # Trigger cleanup
        auth_service._cleanup_expired_states()
        
        # Valid state should remain, expired should be removed
        assert valid_state in auth_service._oauth_states
        assert expired_state not in auth_service._oauth_states
    
    def test_get_oauth_state_info(self, auth_service):
        """Test getting OAuth state information"""
        user_id = "test_user_123"
        state, _ = auth_service.generate_oauth_state(user_id)
        
        info = auth_service.get_oauth_state_info(state)
        
        assert info is not None
        assert info["user_id"] == user_id
        assert not info["used"]
        assert info["use_pkce"] is True
        
        # Non-existent state
        assert auth_service.get_oauth_state_info("nonexistent") is None
    
    def test_pkce_challenge_generation(self, auth_service):
        """Test PKCE challenge generation"""
        code_verifier, code_challenge = auth_service._generate_pkce_challenge()
        
        # Verify code verifier format
        assert len(code_verifier) >= 43
        assert len(code_verifier) <= 128
        
        # Verify code challenge format
        assert len(code_challenge) > 0
        
        # Verify challenge is different from verifier
        assert code_challenge != code_verifier
        
        # Verify reproducibility
        import hashlib
        import base64
        expected_challenge = base64.urlsafe_b64encode(
            hashlib.sha256(code_verifier.encode('utf-8')).digest()
        ).decode('utf-8').rstrip('=')
        assert code_challenge == expected_challenge
    
    def test_encryption_decryption(self, auth_service):
        """Test token encryption and decryption"""
        test_token = "test_access_token_12345"
        
        # Test encryption
        encrypted = auth_service._encrypt_sensitive_data(test_token)
        
        # Should be different from original (if encryption is enabled)
        if auth_service._cipher:
            assert encrypted != test_token
        
        # Test decryption
        decrypted = auth_service._decrypt_sensitive_data(encrypted)
        assert decrypted == test_token
    
    def test_state_cleanup_on_memory_limit(self, auth_service):
        """Test state cleanup when memory limit is reached"""
        user_id = "test_user_123"
        
        # Set a low limit for testing
        auth_service._max_stored_states = 5
        
        # Generate more states than the limit
        states = []
        for i in range(10):
            state, _ = auth_service.generate_oauth_state(f"{user_id}_{i}")
            states.append(state)
        
        # Should have cleaned up oldest states
        assert len(auth_service._oauth_states) <= auth_service._max_stored_states
        
        # Newest states should still exist
        for state in states[-3:]:  # Check last 3 states
            assert state in auth_service._oauth_states
    
    def test_validate_oauth_state_with_additional_checks(self, auth_service):
        """Test OAuth state validation with additional security checks"""
        user_id = "test_user_123"
        state, _ = auth_service.generate_oauth_state(user_id)
        
        # Set additional data in state
        auth_service._oauth_states[state]["ip_address"] = "192.168.1.1"
        auth_service._oauth_states[state]["user_agent"] = "TestAgent/1.0"
        
        # Should validate with matching additional checks
        additional_checks = {
            "ip_address": "192.168.1.1",
            "user_agent": "TestAgent/1.0"
        }
        assert auth_service.validate_oauth_state(state, user_id, additional_checks) is True
        
        # Should fail with mismatched IP
        state2, _ = auth_service.generate_oauth_state(user_id)
        auth_service._oauth_states[state2]["ip_address"] = "192.168.1.1"
        
        mismatched_checks = {"ip_address": "192.168.1.2"}
        assert auth_service.validate_oauth_state(state2, user_id, mismatched_checks) is False
    
    def test_get_connection_security_info(self, auth_service, mock_db_session):
        """Test getting connection security information"""
        mock_connection = Mock(spec=ZoteroConnection)
        mock_connection.id = "conn_123"
        mock_connection.connection_type = "oauth"
        mock_connection.created_at = datetime.now()
        mock_connection.connection_metadata = {
            "pkce_used": True,
            "oauth_version": "2.0",
            "security_features": {
                "encryption_enabled": True
            }
        }
        
        security_info = auth_service.get_connection_security_info(mock_connection)
        
        assert security_info["connection_id"] == "conn_123"
        assert security_info["connection_type"] == "oauth"
        assert security_info["pkce_used"] is True
        assert security_info["encryption_enabled"] is True
        assert "security_score" in security_info
        assert 0 <= security_info["security_score"] <= 100
    
    def test_security_score_calculation(self, auth_service):
        """Test security score calculation"""
        # High security connection
        high_security_conn = Mock(spec=ZoteroConnection)
        high_security_conn.connection_type = "oauth"
        high_security_conn.connection_status = "active"
        high_security_conn.connection_metadata = {
            "pkce_used": True,
            "oauth_version": "2.0",
            "security_features": {"encryption_enabled": True},
            "last_validated": datetime.now().isoformat()
        }
        
        high_score = auth_service._calculate_security_score(high_security_conn)
        
        # Low security connection
        low_security_conn = Mock(spec=ZoteroConnection)
        low_security_conn.connection_type = "api_key"
        low_security_conn.connection_status = "error"
        low_security_conn.connection_metadata = {
            "pkce_used": False,
            "security_features": {"encryption_enabled": False}
        }
        
        low_score = auth_service._calculate_security_score(low_security_conn)
        
        # High security should score higher
        assert high_score > low_score
        assert high_score >= 80  # Should be high
        assert low_score <= 40   # Should be low


if __name__ == "__main__":
    pytest.main([__file__])